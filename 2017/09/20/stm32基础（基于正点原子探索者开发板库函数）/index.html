<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>STM32基础（基于正点原子探索者开发板库函数） | Darren</title><meta name="keywords" content="STM32"><meta name="author" content="Darren"><meta name="copyright" content="Darren"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言 STM32基础，基于正点原子探索者开发板，必须掌握的部分写在前面，入门之后再扩充其他内容，所以顺序并不完全按照正点原子教程的顺序，去除一些个人认为暂时不需要重点掌握的内容，加上一些比较重要的东西。学习方法：重点章节教程视频过一遍，可以有很多疑问先直接跳过，然后看下面总结好的东西，实验自己写一边，再把视频1.5倍速过一遍，查漏补缺，之后再深入，以项目主导学习，缺什么补什么，切忌陷入太多细节问">
<meta property="og:type" content="article">
<meta property="og:title" content="STM32基础（基于正点原子探索者开发板库函数）">
<meta property="og:url" content="https://letang.xyz/2017/09/20/stm32%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9F%BA%E4%BA%8E%E6%AD%A3%E7%82%B9%E5%8E%9F%E5%AD%90%E6%8E%A2%E7%B4%A2%E8%80%85%E5%BC%80%E5%8F%91%E6%9D%BF%E5%BA%93%E5%87%BD%E6%95%B0%EF%BC%89/index.html">
<meta property="og:site_name" content="Darren">
<meta property="og:description" content="前言 STM32基础，基于正点原子探索者开发板，必须掌握的部分写在前面，入门之后再扩充其他内容，所以顺序并不完全按照正点原子教程的顺序，去除一些个人认为暂时不需要重点掌握的内容，加上一些比较重要的东西。学习方法：重点章节教程视频过一遍，可以有很多疑问先直接跳过，然后看下面总结好的东西，实验自己写一边，再把视频1.5倍速过一遍，查漏补缺，之后再深入，以项目主导学习，缺什么补什么，切忌陷入太多细节问">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/letanga/MyPictureBed/img/src=http---file2.dzsc.com-data-18-01-26-111730918.png&refer=http---file2.dzsc.jpg">
<meta property="article:published_time" content="2017-09-20T05:24:55.000Z">
<meta property="article:modified_time" content="2021-05-31T17:51:15.308Z">
<meta property="article:author" content="Darren">
<meta property="article:tag" content="STM32">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/letanga/MyPictureBed/img/src=http---file2.dzsc.com-data-18-01-26-111730918.png&refer=http---file2.dzsc.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://letang.xyz/2017/09/20/stm32%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9F%BA%E4%BA%8E%E6%AD%A3%E7%82%B9%E5%8E%9F%E5%AD%90%E6%8E%A2%E7%B4%A2%E8%80%85%E5%BC%80%E5%8F%91%E6%9D%BF%E5%BA%93%E5%87%BD%E6%95%B0%EF%BC%89/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'STM32基础（基于正点原子探索者开发板库函数）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-06-01 01:51:15'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/letanga/MyPictureBed/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" onclick="btf.scrollToDest(0, 500)" data-title="点击返回顶部">STM32基础（基于正点原子探索者开发板库函数）</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">STM32基础（基于正点原子探索者开发板库函数）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2017-09-20T05:24:55.000Z" title="undefined 2017-09-20 13:24:55">2017-09-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/STM32/">STM32</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">18.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>66分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="STM32基础（基于正点原子探索者开发板库函数）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2017/09/20/stm32%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9F%BA%E4%BA%8E%E6%AD%A3%E7%82%B9%E5%8E%9F%E5%AD%90%E6%8E%A2%E7%B4%A2%E8%80%85%E5%BC%80%E5%8F%91%E6%9D%BF%E5%BA%93%E5%87%BD%E6%95%B0%EF%BC%89/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2017/09/20/stm32%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9F%BA%E4%BA%8E%E6%AD%A3%E7%82%B9%E5%8E%9F%E5%AD%90%E6%8E%A2%E7%B4%A2%E8%80%85%E5%BC%80%E5%8F%91%E6%9D%BF%E5%BA%93%E5%87%BD%E6%95%B0%EF%BC%89/" itemprop="commentCount"></span></a></span></div></div></div><article class="post-content" id="article-container"><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>STM32基础，基于正点原子探索者开发板，必须掌握的部分写在前面，入门之后再扩充其他内容，所以顺序并不完全按照正点原子教程的顺序，去除一些个人认为暂时不需要重点掌握的内容，加上一些比较重要的东西。学习方法：重点章节教程视频过一遍，可以有很多疑问先直接跳过，然后看下面总结好的东西，实验自己写一边，再把视频1.5倍速过一遍，查漏补缺，之后再深入，以项目主导学习，缺什么补什么，切忌陷入太多细节问题，切忌太过追求全面。</p>
<h2 id="开发板资源"><a class="markdownIt-Anchor" href="#开发板资源"></a> 开发板资源</h2>
<p>先了解开发板有哪些资源，可直接跳过，以后学习用到了哪些资源再回头来看；</p>
<p><strong>开发板资源图</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/r1JFl4"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/16/r1JFl4.jpg" alt="r1JFl4.jpg" /></a></p>
<p><strong>开发板资源列表</strong></p>
<ul>
<li>CPU STM32F407ZGT6 LQFP144 FLASH 1024K SRAM 192K</li>
<li>外扩 SRAM XM8A51216 1M字节</li>
<li>外扩 SPI FLASH W25Q128 16M字节</li>
<li>1个电源指示灯（蓝色）</li>
<li>2个状态指示灯（ DS0：红色 DS1：绿色</li>
<li>1个红外接收头，并配备一款小巧的红外遥控器</li>
<li>1个 EEPROM芯片， ，24C02，容量 256字节</li>
<li>1个六轴（陀螺仪 +加速度）传感器芯片， MPU6050</li>
<li>1个高性能音频编解码芯片， WM8978</li>
<li>1个 2.4G无线模块接口，支持 NRF24L01无线模块</li>
<li>1路 CAN接口，采用 TJA1050芯片</li>
<li>1路 485接口，采用 SP3485芯片</li>
<li>2路 RS232串口（一公一母）接口，采用 SP3232芯片</li>
<li>1路单总线接口，支持 DS18B20/DHT11等单总线传感器</li>
<li>1个 ATK模块接口，支持 ALIENTEK蓝牙 /GPS模块</li>
<li>1个光敏传感器</li>
<li>1个标准的 2.4/2.8/3.5/4.3/7寸 LCD接口，支持电阻 /电容触摸屏</li>
<li>1个摄像头模块接口</li>
<li>1个 OLED模块接口</li>
<li>1个 USB串口，可用于程序下载和代码调试（ USMART调试）</li>
<li>1个 USB SLAVE接口，用于 USB从机通信</li>
<li>1个 USB HOST(OTG)接口，用于 USB主机通信</li>
<li>1个有源蜂鸣器</li>
<li>1个 RS232/RS485选择接口</li>
<li>1个 RS232/模块选择接口</li>
<li>1个 CAN/USB选择接口</li>
<li>1个串口选择接口</li>
<li>1个 SD卡接口（在板子背面）</li>
<li>1个百兆以太网接口（ RJ45</li>
<li>1个标准的 JTAG/SWD调试下载口</li>
<li>1个录音头（ MIC/咪头）</li>
<li>1路立体声音频输出接口</li>
<li>1路立体声录音输入接口</li>
<li>1路扬声器输出接口，可接 1W左右小喇叭</li>
<li>1组多功能端口（ DAC/ADC/PWM DAC/AUDIO IN/TPAD</li>
<li>1组 5V电源供应 /接入口</li>
<li>1组 3.3V电源供应 /接入口</li>
<li>1个参考电压设置接口</li>
<li>1个直流电源输入接口（输入电压范围： DC6~16V</li>
<li>1个启动模式选择配置接口</li>
<li>1个 RTC后备电池座，并带电池</li>
<li>1个复位按钮，可用于复位 MCU和 LCD</li>
<li>4个功能按钮，其中 KEY_UP(即 WK_UP)兼具唤醒功能</li>
<li>1个电容触摸按键</li>
<li>1个电源开关，控制整个板的电源</li>
<li>一键下载功能</li>
<li>除晶振占用的 IO口外，其余所有 IO口全部引出</li>
</ul>
<h2 id="一些常识"><a class="markdownIt-Anchor" href="#一些常识"></a> 一些常识</h2>
<p><strong>stm32的命名规则：</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/r3iN6g"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/17/r3iN6g.png" alt="r3iN6g.png" /></a></p>
<p><strong>RAM：</strong> 随机存储器，可读可写，特点是掉电会丢失数据。RAM又分为SRAM(Static RAM)和DRAM(Dynamic RAM)，SRAM是读写速度非常快的存储设备，但价格昂贵。DRAM比ROM速度快，但是比SRAM速度慢，价格低于SRAM，计算机内存使用的就是DRAM；</p>
<p><strong>FLASH：</strong> 闪存，这种存储器结合了ROM和RAM的优点，既可以保证掉电不丢失又可以有很高的读写速度。可以用来存储一些用户不希望掉电丢失的一些数据；</p>
<p>在以往，单片机内部包含ROM和RAM，ROM的硬件实现主要EEPROM，但近年来Flash逐渐取代了他的位置，成为ROM实现的主要硬件。例如，51单片机有4KB的ROM和256B的RAM，这里的ROM实现为EEPROM，而STM31F103有64KB的Flash和20K的SRAM，这里Flash的一部分作为ROM来使用；</p>
<p><strong>stm32常用的开发工具：</strong> MDK(keil)，IAR，STM32CubeMX；</p>
<h2 id="程序下载"><a class="markdownIt-Anchor" href="#程序下载"></a> 程序下载</h2>
<p><strong>ISP串口下载：</strong> 速度太慢，一般使用J-LINK下载；</p>
<p>STM32的ISP下载，只能使用串口1，也就是对应串口发送接收引脚PA9,PA10。不能使用其他串口（例如串口2：PA2,PA3)用来ISP下载；</p>
<p><strong>J-LINK下载：</strong> 一般使用SWD模式，只需要两根线就可以下载和调试，编译好程序后点击LOAD下载程序到开发板但需要提前配置好下载环境，MDK配置，在Debug选项卡选择J-LINK/J-TAG Cortex，再点setting，选择SW，还要在下载选项卡设置添加对应的设备，两项设置好了才能下载，不然会报错无法下载；</p>
<p>一般来说下好程序后，重启芯片时，<strong>SYSCLK的第4个上升沿，BOOT引脚的值将被锁存</strong>，用户可以通过设置BOOT1和BOOT0引脚的状态，来选择在复位后的启动模式。</p>
<p>STM32上电或者复位后，代码区始终从0x00000000开始，三种启动模式其实就是将各自存储空间的地址映射到0x00000000中：</p>
<ol>
<li>从Flash启动，将主Flash地址0x08000000映射到0x00000000，这样代码启动之后就相当于从0x08000000开始；</li>
<li>从RAM启动，将RAM地址0x20000000映射到0x00000000,这样代码启动之后就相当于从0x20000000开始；</li>
<li>从系统存储器启动。首先控制BOOT0 BOOT1管脚，复位后，STM32与上述两种方式类似，从系统存储器地址0x1FFF F000开始执行代码，系统存储器存储的其实就是STM32自带的bootloader代码，在bootloader中提供了UART1的接口，通过此接口可以将用户所需的程序代码下载到主Flash中，下载完毕后，此时程序代码已经存储在主Flash当中，这时切换启动模式（从主Flash启动），复位后所执行的就是刚刚下载到Flash中的代码了；</li>
</ol>
<p>STM32三种启动模式对应的存储介质均是芯片内置的，如下图：</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/r36m8J"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/17/r36m8J.png" alt="r36m8J.png" /></a></p>
<ol>
<li>用户闪存 ： 芯片内置的Flash，正常的工作模式。</li>
<li>SRAM： 芯片内置的RAM区，就是内存，可以用于调试。</li>
<li>系统存储器： 芯片内部一块特定的区域，芯片出厂时在这个区域预置了一段Bootloader，就是通常说的ISP程序，这个区域的内容在芯片出厂后没有人能够修改或擦除，即它是一个ROM区。启动的程序功能由厂家设置。</li>
</ol>
<p><strong>Main Flash memory:</strong> 是STM32内置的Flash，一般我们使用JTAG或者SWD模式下载程序时，就是下载到这个里面，重启后也直接从这启动程序。</p>
<p><strong>System memory:</strong> 从系统存储器启动，这种模式启动的程序功能是由厂家设置的。一般来说，这种启动方式用的比较少。<br />
系统存储器是芯片内部一块特定的区域，STM32在出厂时，由ST在这个区域内部预置了一段BootLoader，也就是我们常说的ISP程序，这是一块ROM，出厂后无法修改。</p>
<p>一般来说，我们选用这种启动模式时，是为了从串口下载程序，因为在厂家提供的BootLoader中，提供了串口下载程序的固件，可以通过这个BootLoader将程序下载到系统的Flash中。但是这个下载方式需要以下步骤：</p>
<p>Step1:将BOOT0设置为1，BOOT1设置为0，然后按下复位键，这样才能从系统存储器启动BootLoader；</p>
<p>Step2:最后在BootLoader的帮助下，通过串口下载程序到Flash中；</p>
<p>Step3:程序下载完成后，又有需要将BOOT0设置为GND，手动复位，这样，STM32才可以从Flash中启动，可以看到，利用串口下载程序还是比较的麻烦，需要跳帽跳来跳去的，非常的不注重用户体验，所以主流的开发板都设计了一键下载电路，方便用户下载程序；</p>
<p><strong>Embedded Memory:</strong></p>
<p>内置SRAM，既然是SRAM，自然也就没有程序存储的能力了，这个模式一般用于程序调试，</p>
<p>假如我只修改了代码中一个小小的地方，然后就需要重新擦除整个Flash，比较的费时，可以考虑从这个模式启动代码（也就是STM32的内存中），用于快速的程序调试，等程序调试完成后，在将程序下载到Flash中；</p>
<p><strong>开发BOOT模式选择：</strong></p>
<ol>
<li>通常使用程序代码存储在主闪存存储器，配置方式：BOOT0=0，BOOT1=X;两个启动引脚通过10K电阻接地；</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/r3gu0x"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/17/r3gu0x.png" alt="r3gu0x.png" /></a></p>
<ol start="2">
<li>Flash锁死解决办法：开发调试过程中，由于某种原因导致内部Flash锁死，无法连接SWD以及Jtag调试，无法读到设备，可以通过修改BOOT模式重新刷写代码，修改为BOOT0=1，BOOT1=0即可从系统存储器启动，ST出厂时自带Bootloader程序，SWD以及JTAG调试接口都是专用的。重新烧写程序后，可将BOOT模式重新更换到BOOT0=0，BOOT1=X即可正常使用；</li>
</ol>
<p>嵌入式系统的启动还需要一段启动代码（bootloader)，类似于启动PC时的BIOS，一般用于完成微控制器的初始化工作和自检，STM32的启动代码在startup_stm32f40x_xx.s（xx根据微控制器所带的大、中、小容量存储器分别为hd、md、ld）中，其中的程序功能主要包括<strong>初始化堆栈、定义程序启动地址、中断向量表和中断服务程序入口地址，以及系统复位启动时，从启动代码跳转到用户main函数的入口地址</strong> ，在后面的启动文件介绍中会有更详细描述；</p>
<p>USB接口，相应电平逻辑遵照USB原则，而单片机上的串行通信通过单片机的RXD、TXD、VCC、GND四个引脚，相应电平逻辑遵照TTL原则，如果要通过USB和单片机串口进行通信，需要转成一样的原则，一种方法是USB转TTL，一种是，TTL转USB，开发板使用的是通过CH340G将USB转TTL，与单片机进行通信；</p>
<p><strong>一键下载电路：</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rh2UNF"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/26/rh2UNF.png" alt="rh2UNF.png" /></a></p>
<p>通过上位机控制BOOT电平，从而实现一键下载，下载时设置DTR的低电平复位，RTS高电平进BootLoader，但是这个上位机是按232标准编写的，与USB标准是相反的，所以实际是DTR的高电平复位，RTS低电平进BootLoader，要分析这个电路，需要对照复位电路和单片机上的RESET连接</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/so3xBV"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2021/01/22/so3xBV.jpg" alt="so3xBV.jpg" /></a></p>
<p>当下载程序时，DTR输出高电平，RTS输出低电平，Q2，Q3，D7导通，RESET和RST是连接上的，即为低电平复位，BOOT0被上拉至高电平，下载完程序后，DTR输出低电平，RTS输出高电平，Q2，Q3，D7截止，RESET被上拉至高电平，Q3截止所以BOOT0为低电平，恢复正常运行模式</p>
<h2 id="工程模板"><a class="markdownIt-Anchor" href="#工程模板"></a> 工程模板</h2>
<p>实验0即是模板，复制过来用就行，怎么用：改主函数和HARDWARE文件夹里的内容，自己写的头文件添加到宏，不需要的宏删除，后面看实验教程看都看会了，不需要特意学视频教程中的工程模板创建；</p>
<h2 id="gpio原理"><a class="markdownIt-Anchor" href="#gpio原理"></a> GPIO原理</h2>
<p><strong>GPIO基本结构：</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/r1d1c8"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/16/r1d1c8.png" alt="r1d1c8.png" /></a></p>
<p><strong>四种输入模式：</strong></p>
<ul>
<li>
<p>输入浮空</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/r1y2LV"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/16/r1y2LV.jpg" alt="r1y2LV.jpg" /></a></p>
<p>I/O端口的电平信号直接进入输入数据寄存器。MCU直接读取I/O口电平，I/O的电平状态是不确定的，完全由外部输入决定；如果在该引脚悬空（在无信号输入）的情况下，读取该端口的电平是不确定的， (接用电压表测量其引脚电压为1点几伏，这是个不确定值) 以用来做KEY识别</p>
</li>
<li>
<p>输入上拉</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/r1y0Ig"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/16/r1y0Ig.jpg" alt="r1y0Ig.jpg" /></a></p>
<p>IO内部接上拉电阻，此时如果IO口外部没有信号输入或者引脚悬空，IO口默认为高电平  如果I/O口输入低电平，那么引脚就为低电平，MCU读取到的就是低电平</p>
</li>
<li>
<p>输入下拉</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/r1yHQ1"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/16/r1yHQ1.jpg" alt="r1yHQ1.jpg" /></a></p>
<p>IO内部接下拉电阻，此时如果IO口外部没有信号输入或者引脚悬空，IO口默认为低电平  如果I/O口输入高电平，那么引脚就为高电平，MCU读取到的就是高电平</p>
</li>
<li>
<p>模拟输入</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/r1yzJH"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/16/r1yzJH.jpg" alt="r1yzJH.jpg" /></a></p>
<p>当GPIO引脚用于ADC采集电压的输入通道时，用作&quot;模拟输入&quot;功能，此时信号不经过施密特触发器，直接直接进入ADC模块，并且输入数据寄存器为空 ，CPU不能在输入数据寄存器上读到引脚状态</p>
<p>当GPIO用于模拟功能时，引脚的上、下拉电阻是不起作用的，这个时候即使配置了上拉或下拉模式，也不会影响到模拟信号的输入输出</p>
</li>
</ul>
<p>除了 ADC 和 DAC 要将 IO 配置为模拟通道之外其他外设功能一律 要配置为复用功能模式</p>
<p><strong>四种输出模式：</strong></p>
<ul>
<li>
<p>开漏输出(带上拉或者下拉)</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/r14zY6"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/16/r14zY6.jpg" alt="r14zY6.jpg" /></a></p>
<p>在开漏输出模式时，只有N-MOS管工作，如果我们控制输出为0，低电平，则P-MOS管关闭，N-MOS管导通，使输出低电平，I/O端口的电平就是低电平，若控制输出为1时，高电平，则P-MOS管和N-MOS管都关闭，输出指令就不会起到作用，此时I/O端口的电平就不会由输出的高电平决定，而是由I/O端口外部的上拉或者下拉决定   如果没有上拉或者下拉 IO口就处于悬空状态</p>
<p>并且此时施密特触发器是打开的，即输入可用，通过输入数据寄存器GPIOx_IDR可读取I/O的实际状态。，I/O口的电平不一定是输出的电平</p>
</li>
<li>
<p>开漏复用功能(带上拉或者下拉)</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/r15up8"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/16/r15up8.jpg" alt="r15up8.jpg" /></a></p>
<p>GPIO复用为其他外设，输出数据寄存器GPIOx_ODR无效； 输出的高低电平的来源于其它外设，施密特触发器打开，输入可用，通过输入数据寄存器可获取I/O实际状态  除了输出信号的来源改变 其他与开漏输出功能相同</p>
</li>
<li>
<p>推挽式输出(带上拉或者下拉)</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/r15iOH"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/16/r15iOH.jpg" alt="r15iOH.jpg" /></a></p>
<p>在推挽输出模式时，N-MOS管和P-MOS管都工作，如果我们控制输出为0，低电平，则P-MOS管关闭，N-MOS管导通，使输出低电平，I/O端口的电平就是低电平，若控制输出为1 高电平，则P-MOS管导通N-MOS管关闭，使输出高电平，I/O端口的电平就是高电平， 外部上拉和下拉的作用是控制在没有输出时IO口电平</p>
<p>此时施密特触发器是打开的，即输入可用，通过输入数据寄存器GPIOx_IDR可读取I/O的实际状态。I/O口的电平一定是输出的电平</p>
</li>
<li>
<p>推挽式复用功能(带上拉或者下拉)</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/r15Jkq"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/16/r15Jkq.jpg" alt="r15Jkq.jpg" /></a></p>
<p>GPIO复用为其他外设(如 I2C)，输出数据寄存器GPIOx_ODR无效； 输出的高低电平的来源于其它外设，施密特触发器打开，输入可用，通过输入数据寄存器可获取I/O实际状态  除了输出信号的来源改变 其他与开漏输出功能相同</p>
</li>
</ul>
<p><strong>开漏输出和推挽输出的区别：</strong></p>
<ul>
<li>
<p>推挽输出：可以输出强高低电平，连接数字器件</p>
<p>推挽结构一般是指两个MOS管分别受两互补信号的控制,总是在一个管导通的时候另一个截止.</p>
</li>
<li>
<p>开漏输出：可以输出强低电平，高电平得靠外部电阻拉高。</p>
<p>输出端相当于MOS管漏极. 需要外接上拉电阻，才能实现输出高电平  合于做电流型的驱动，其吸收电流的能力相对强(一般20ma以内)，在使用开漏模式时，都需要接上拉电阻，否则只能输出低电平；</p>
</li>
</ul>
<p>STM32F4的大部分端口都具有复用功能，所谓复用，就是一些端口不仅仅可以做为通用IO口，还可以复用为一些外设引脚，比如PA9,PA10可以复用为STM32F4的串口1引脚，作用：最大限度的利用端口资源</p>
<p>所有IO口都可以作为中断输入；</p>
<h2 id="跑马灯实验"><a class="markdownIt-Anchor" href="#跑马灯实验"></a> 跑马灯实验</h2>
<p><strong>硬件连接：</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/r1v9pj"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/16/r1v9pj.png" alt="r1v9pj.png" /></a></p>
<p><strong>共阳极连接</strong>，所以输出为低电平时，LED灯亮，输出高电平时，LED灯灭</p>
<p><strong>一些常用的GPIO库函数：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1个初始化函数：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2个读取输入电平函数：</span></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">GPIO_ReadInputDataBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> GPIO_Pin)</span></span>;<span class="comment">//用于读取一个或几个IO口的输入状态</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">GPIO_ReadInputData</span><span class="params">(GPIO_TypeDef* GPIOx)</span></span>;<span class="comment">//用于读取一组IO口的输入状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2个读取输出电平函数：</span></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">GPIO_ReadOutputDataBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> GPIO_Pin)</span></span>;<span class="comment">//用于读取一个或几个IO口的输出状态</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">GPIO_ReadOutputData</span><span class="params">(GPIO_TypeDef* GPIOx)</span></span>;<span class="comment">//用于读取一组IO口的输出状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4个设置输出电平函数：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_SetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> GPIO_Pin)</span></span>;<span class="comment">//用于设置一个或者多个IO口为高电平</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> GPIO_Pin)</span></span>;<span class="comment">//用于设置一个或者多个IO口为低电平</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_WriteBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> GPIO_Pin, BitAction BitVal)</span></span>;<span class="comment">//用于设置一个或者多个IO口为高电平或者低电平</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_Write</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="keyword">uint16_t</span> PortVal)</span></span>;<span class="comment">//用于设置一组IO口为高电平或低电平</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>跑马灯实验代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//led.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LED_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _LED_H_</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	delay_init(<span class="number">168</span>);</span><br><span class="line">	LED_Init();</span><br><span class="line">	<span class="keyword">for</span>(;;)</span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_SetBits(GPIOF,GPIO_Pin_9);<span class="comment">//set置1，reset置0</span></span><br><span class="line">		GPIO_ResetBits(GPIOF,GPIO_Pin_10);</span><br><span class="line">		delay_ms(<span class="number">500</span>);</span><br><span class="line">		GPIO_ResetBits(GPIOF,GPIO_Pin_9);</span><br><span class="line">		GPIO_SetBits(GPIOF,GPIO_Pin_10);</span><br><span class="line">		delay_ms(<span class="number">500</span>);</span><br><span class="line">        <span class="comment">//位带操作</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        PFout(9)=0;</span></span><br><span class="line"><span class="comment">		PFout(10)=1;</span></span><br><span class="line"><span class="comment">		delay_ms(500);</span></span><br><span class="line"><span class="comment">		PFout(9)=1;</span></span><br><span class="line"><span class="comment">		PFout(10)=0;</span></span><br><span class="line"><span class="comment">		delay_ms(500);</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LED.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*GPIO_InitTypeDef GPIO_Init_Structure;</span></span><br><span class="line"><span class="comment">	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF,ENABLE);</span></span><br><span class="line"><span class="comment">	//F9</span></span><br><span class="line"><span class="comment">	GPIO_Init_Structure.GPIO_Mode=GPIO_Mode_OUT;</span></span><br><span class="line"><span class="comment">	GPIO_Init_Structure.GPIO_OType=GPIO_OType_PP;</span></span><br><span class="line"><span class="comment">	GPIO_Init_Structure.GPIO_Pin=GPIO_Pin_9;</span></span><br><span class="line"><span class="comment">	GPIO_Init_Structure.GPIO_PuPd=GPIO_PuPd_DOWN;</span></span><br><span class="line"><span class="comment">	GPIO_Init_Structure.GPIO_Speed=GPIO_Fast_Speed;</span></span><br><span class="line"><span class="comment">	GPIO_Init(GPIOF,&amp;GPIO_Init_Structure);</span></span><br><span class="line"><span class="comment">	GPIO_SetBits(GPIOF,GPIO_Pin_9);</span></span><br><span class="line"><span class="comment">	//F10</span></span><br><span class="line"><span class="comment">	GPIO_Init_Structure.GPIO_Mode=GPIO_Mode_OUT;</span></span><br><span class="line"><span class="comment">	GPIO_Init_Structure.GPIO_OType=GPIO_OType_PP;</span></span><br><span class="line"><span class="comment">	GPIO_Init_Structure.GPIO_Pin=GPIO_Pin_10;</span></span><br><span class="line"><span class="comment">	GPIO_Init_Structure.GPIO_PuPd=GPIO_PuPd_DOWN;</span></span><br><span class="line"><span class="comment">	GPIO_Init_Structure.GPIO_Speed=GPIO_Fast_Speed;</span></span><br><span class="line"><span class="comment">	GPIO_Init(GPIOF,&amp;GPIO_Init_Structure);</span></span><br><span class="line"><span class="comment">	GPIO_setBits(GPIOF,GPIO_Pin_10);*/</span></span><br><span class="line">    GPIO_InitTypeDef GPIO_Init_Structure;<span class="comment">//定义一个GPIO_InitTypeDef类型的结构体变量</span></span><br><span class="line">    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF,ENABLE);<span class="comment">//使能GPIOF时钟</span></span><br><span class="line">	GPIO_Init_Structure.GPIO_Mode=GPIO_Mode_OUT;<span class="comment">//设置输出模式</span></span><br><span class="line">	GPIO_Init_Structure.GPIO_OType=GPIO_OType_PP;<span class="comment">//设置推挽模式</span></span><br><span class="line">	GPIO_Init_Structure.GPIO_Pin=GPIO_Pin_9|GPIO_Pin_10;<span class="comment">//设置9和10引脚</span></span><br><span class="line">	GPIO_Init_Structure.GPIO_PuPd=GPIO_PuPd_UP;<span class="comment">//设置上拉模式</span></span><br><span class="line">	GPIO_Init_Structure.GPIO_Speed=GPIO_Fast_Speed;<span class="comment">//设置传输速度</span></span><br><span class="line">	GPIO_Init(GPIOF,&amp;GPIO_Init_Structure);<span class="comment">//按照设置初始化</span></span><br><span class="line">	GPIO_SetBits(GPIOF,GPIO_Pin_9|GPIO_Pin_10);<span class="comment">//设置9和10引脚输出高电平</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="蜂鸣器实验"><a class="markdownIt-Anchor" href="#蜂鸣器实验"></a> 蜂鸣器实验</h2>
<p><strong>硬件连接：</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/r3i6pT"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/17/r3i6pT.png" alt="r3i6pT.png" /></a></p>
<p>输出为高电平时，蜂鸣器响</p>
<p><strong>蜂鸣器实验代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//beep.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _BEEP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _BEEP_H_</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BEEP_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BEEP.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BEEP_Init();</span><br><span class="line">	delay_init(<span class="number">168</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		PFout(<span class="number">8</span>)=<span class="number">0</span>;</span><br><span class="line">		delay_ms(<span class="number">500</span>);</span><br><span class="line">		PFout(<span class="number">8</span>)=<span class="number">1</span>;</span><br><span class="line">		delay_ms(<span class="number">500</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//beep.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BEEP.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BEEP_Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_Init_Structure;<span class="comment">//定义一个GPIO_InitTypeDef类型的结构体变量</span></span><br><span class="line">	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF,ENABLE);<span class="comment">//使能GPIOF时钟</span></span><br><span class="line">	GPIO_Init_Structure.GPIO_Mode=GPIO_Mode_OUT;<span class="comment">//设置输出模式</span></span><br><span class="line">	GPIO_Init_Structure.GPIO_OType=GPIO_OType_PP;<span class="comment">//设置推挽模式</span></span><br><span class="line">	GPIO_Init_Structure.GPIO_Pin=GPIO_Pin_8;<span class="comment">//设置8引脚</span></span><br><span class="line">	GPIO_Init_Structure.GPIO_PuPd=GPIO_PuPd_DOWN;<span class="comment">//设置下拉</span></span><br><span class="line">	GPIO_Init_Structure.GPIO_Speed=GPIO_Fast_Speed;<span class="comment">//设置传输速度</span></span><br><span class="line">	GPIO_Init(GPIOF,&amp;GPIO_Init_Structure);<span class="comment">//按照设置初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="按键输入实验"><a class="markdownIt-Anchor" href="#按键输入实验"></a> 按键输入实验</h2>
<p><strong>硬件连接：</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rGejs0"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/17/rGejs0.png" alt="rGejs0.png" /></a></p>
<p>实现<strong>支持连续按和不支持连续按两种模式切换</strong> ，当mode=0时，不支持连续按，伪代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u8 <span class="title">KEY_Scan</span><span class="params">(u8 mode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     <span class="keyword">static</span> u8 key_up=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span>(mode==<span class="number">1</span>) key_up=<span class="number">1</span>;<span class="comment">//支持连续按</span></span><br><span class="line">      <span class="keyword">if</span>（key_up &amp;&amp;  KEY按下）</span><br><span class="line">      &#123;</span><br><span class="line">        delay_ms(<span class="number">10</span>);<span class="comment">//延时，防抖</span></span><br><span class="line">        key_up=<span class="number">0</span>;<span class="comment">//标记这次key已经按下</span></span><br><span class="line">        <span class="keyword">if</span>(KEY确实按下)</span><br><span class="line">          &#123;</span><br><span class="line">           <span class="keyword">return</span> KEY_VALUE;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(KEY没有按下)  key_up=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> 没有按下</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>按键输入实验代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//led.h beep.h led.c beep.c和跑马灯和蜂鸣器实验一样</span></span><br><span class="line"><span class="comment">//key.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>	_KEY_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _KEY_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY_0 GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY_1 GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY_2 GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WK_UP GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KEY_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">u8 <span class="title">KEY_Scan</span><span class="params">(u8 mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;beep.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 keyvalue;</span><br><span class="line">	delay_init(<span class="number">168</span>);</span><br><span class="line">	LED_Init();</span><br><span class="line">	BEEP_Init();</span><br><span class="line">	KEY_Init();</span><br><span class="line">	PFout(<span class="number">9</span>)=<span class="number">1</span>;</span><br><span class="line">	PFout(<span class="number">10</span>)=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		keyvalue=KEY_Scan(<span class="number">0</span>);<span class="comment">//不支持连续按</span></span><br><span class="line">		<span class="keyword">if</span>(keyvalue)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">switch</span>(keyvalue)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">					PFout(<span class="number">9</span>)=!PFout(<span class="number">9</span>);<span class="comment">//绿灯翻转</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">					PFout(<span class="number">10</span>)=!PFout(<span class="number">10</span>);<span class="comment">//红灯翻转</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">					PFout(<span class="number">9</span>)=!PFout(<span class="number">9</span>);</span><br><span class="line">					PFout(<span class="number">10</span>)=!PFout(<span class="number">10</span>);<span class="comment">//两个灯都翻转</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">					PFout(<span class="number">8</span>)=!PFout(<span class="number">8</span>);<span class="comment">//蜂鸣器响和不响</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> delay_ms(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//key.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KEY_Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_Init_Structure;</span><br><span class="line">	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA|RCC_AHB1Periph_GPIOE,ENABLE);</span><br><span class="line">	GPIO_Init_Structure.GPIO_Pin=GPIO_Pin_2|GPIO_Pin_3|GPIO_Pin_4;</span><br><span class="line">	GPIO_Init_Structure.GPIO_Mode=GPIO_Mode_IN;</span><br><span class="line">	GPIO_Init_Structure.GPIO_PuPd=GPIO_PuPd_UP;</span><br><span class="line">	GPIO_Init_Structure.GPIO_Speed=GPIO_Fast_Speed;</span><br><span class="line">	GPIO_Init(GPIOE,&amp;GPIO_Init_Structure);</span><br><span class="line">	</span><br><span class="line">	GPIO_Init_Structure.GPIO_Pin=GPIO_Pin_0;</span><br><span class="line">	GPIO_Init_Structure.GPIO_PuPd=GPIO_PuPd_DOWN;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_Init_Structure);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">u8 <span class="title">KEY_Scan</span><span class="params">(u8 mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> u8 key_up=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(mode)</span><br><span class="line">	&#123;</span><br><span class="line">		key_up=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(key_up&amp;&amp;(KEY_0==<span class="number">0</span>||KEY_1==<span class="number">0</span>||KEY_2==<span class="number">0</span>||WK_UP==<span class="number">1</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		delay_ms(<span class="number">10</span>);</span><br><span class="line">		key_up=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(KEY_0==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(KEY_1==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(KEY_2==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(WK_UP==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(KEY_0==<span class="number">1</span>&amp;&amp;KEY_1==<span class="number">1</span>&amp;&amp;KEY_2==<span class="number">1</span>&amp;&amp;WK_UP==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		key_up=<span class="number">1</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="时钟树"><a class="markdownIt-Anchor" href="#时钟树"></a> 时钟树</h2>
<p>时钟系统是CPU的脉搏，就像人的心跳一样， STM32F4的时钟系统比较复杂，不像简单的51单片机一个系统时钟就可以解决一切，这是因为STM32本身非常复杂，外设非常的多，但是并不是所有外设都需要系统时钟这么高的频率，比如看门狗以及RTC只需要几十k的时钟即可，同一个电路，时钟越快功耗越大，同时抗电磁干扰能力也会越弱，所以对于较为复杂的MCU一般都是采取多时钟源的方法来解决这些问题；</p>
<p><strong>STM32F4的时钟系统图：</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rJzx9f"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/18/rJzx9f.jpg" alt="rJzx9f.jpg" /></a></p>
<p>在STM32F4中，有5个最重要的时钟源，为LSI、LSE、HSI、HSE、PLL，其中PLL实际是分为两个时钟源，分别为主PLL和专用PLL。从时钟频率来分可以分为高速时钟源和低速时钟源，在这5个中HSI，HSE以及PLL是高速时钟，LSI和LSE是低速时钟。从来源可分为外部时钟源和内部时钟源，外部时钟源就是从外部通过接晶振的方式获取时钟源，其中HSE和LSE是外部时钟源，其他的是内部时钟源；</p>
<p><strong>位置：</strong> 顺序从上到下LSI、LSE、HSI、HSE、PLL，带E的时钟和PLL靠近外侧，带I的时钟靠近内侧；</p>
<p><strong>STM32F4的5个时钟源：</strong></p>
<ul>
<li>
<p>LSI是低速内部时钟，RC振荡器，频率为32kHz左右，供独立看门狗和自动唤醒单元使用</p>
</li>
<li>
<p>LSE是低速外部时钟，接频率为32.768kHz的石英晶体，这个主要是RTC的时钟源</p>
</li>
<li>
<p>HSI是高速内部时钟，RC振荡器，频率为16MHz，可以直接作为系统时钟或者用作PLL输入</p>
</li>
<li>
<p>HSE是高速外部时钟，可接石英/陶瓷谐振器，或者接外部时钟源，频率范围为4MHz~26MHz，HSE也可以直接做为系统时钟或者PLL输入</p>
</li>
<li>
<p>PLL为锁相环倍频输出，STM32F4有两个PLL，均由HSE 或者HSI 提供时钟输入信号:</p>
<ul>
<li>
<p>主PLL两个不同的输出时钟。</p>
<ul>
<li>
<p>第一个输出PLLP用于生成高速的系统时钟（最高168MHz）</p>
</li>
<li>
<p>第二个输出PLLQ用于USB OTG FS 的时钟（48M）、RNG（随机数发生器） 和SDIO 时钟</p>
</li>
</ul>
</li>
<li>
<p>专用PLL(PLLI2S)用于生成精确时钟，从而在I2S接口实现高品质音频性能</p>
</li>
</ul>
</li>
</ul>
<p><strong>主PLL时钟第一个高速时钟输出PLLP的计算方法：</strong></p>
<p>主PLL时钟的时钟源要先经过一个分频系数为M（2 ~ 63）的分频器，得到VCO输入信号（范围1 ~2M）然后经过倍频系数为N的倍频器出来之后，得到VCO输出信号（范围193 ~ 432M）还需要经过一个分频系数为P（第一个输出PLLP）或者Q（第二个输出PLLQ）的分频器分频之后，最后才生成最终的主PLL时钟</p>
<p>假设外部晶振选择8MHz，同时设置相应的分频器M=8，倍频器倍频系数N=336，</p>
<p>分频器分频系数P=2，那么主PLL生成的第一个输出高速时钟PLLP为：</p>
<p>PLL=8MHz *  N/ (M*P)=8MHz * 336 /(8 * 2) = 168MHz</p>
<p>如果我们选择HSE为PLL时钟源，同时SYSCLK时钟源为PLL，那么SYSCLK时钟为168MHz，后面的实验都是采用这样的配置</p>
<p><strong>IWDGCLK：</strong> 看门狗时钟的输入，看门狗时钟源只能是低速的LSI时钟；</p>
<p><strong>RTCCLK：</strong> RTC时钟源，RTC的时钟源可以选择LSI，LSE，以及HSE分频后的时钟，HSE分频系数为2~31，通常的做法是由LSE 给RTC 提供时钟，大小为32.768KHZ，LSE由外接的晶体谐振器产生，所配的谐振电容精度要求高，不然很容易不起震，选择方式是编程 RCC 备份域控制寄存器 (RCC_BDCR) 中的 RTCSEL[1:0] 位和 RCC 时钟配置寄存器 (RCC_CFGR) 中的 RTCPRE[4:0] 位；</p>
<p><strong>SYSCLK：</strong> 系统时钟，SYSCLK系统时钟来源：HSI,HSE和PLL，在实际应用中，因为对时钟速度要求都比较高我们才会选用STM32F4这种级别的处理器，所以一般情况下，都是采用PLL作为SYSCLK时钟源，当HSE 出现故障的时候（PLL时钟来源HSE时钟），系统时钟会切换为HSI=16M，直到HSE 恢复正常为止根据前面的计算公式，可以算出你的系统的SYSCLK是多少，具体的由时钟配置寄存器RCC_CFGR的SW 位配置；</p>
<p><strong>HCLK：</strong> AHB 总线时钟，系统时钟SYSCLK 经过AHB 预分频器分频之后得到时钟叫AHB 总线时钟，即HCLK，分频因子可以是:[1， 2，4，8，16，64，128，256，512]，具体的由时钟配置寄存器RCC_CFGR 的HPRE 位设置，片上大部分外设的时钟都是经过HCLK 分频得到，至于AHB总线上的外设的时钟设置为多少，得等到使用该外设的时候才设置，这里设置为1 分频，即HCLK=SYSCLK=168M；</p>
<p>**HCLK2：**APB2 总线时钟PCLK2， 由HCLK 经过高速APB2 预分频器得到，分频因子可以是:[1，2，4，8，16]，具体由时钟配置寄存器RCC_CFGR 的PPRE2 位设置。HCLK2 属于高速的总线时钟，片上高速的外设就挂载到这条总线上</p>
<p><strong>HCLK1：</strong> APB1 总线时钟PCLK1 由HCLK 经过低速APB 预分频器得到，分频因子可以是:[1，2，4，8，16]，具体由时钟配置寄存器RCC_CFGR 的PPRE1 位设置，HCLK1 属于低速的总线时钟，最高为42M，片上低速的外设就挂载到这条总线上</p>
<p><strong>I2S时钟源：</strong> I2S的时钟源来源于PLLI2S或者映射到I2S_CKIN引脚的外部时钟，I2S出于音质的考虑，对时钟精度要求很高，STM32F4开发板使用的是内部PLLI2SCLK。</p>
<p><strong>输出时钟MCO1和MCO2：</strong> MCO1是向芯片的PA8引脚输出时钟，它有四个时钟来源分别为：HSI,LSE,HSE和PLL时钟，MCO2是向芯片的PC9输出时钟，它同样有四个时钟来源分别为：HSE,PLL，SYSCLK以及PLLI2S时钟，MCO输出时钟频率最大不超过100MHz；</p>
<p>以太网PTP时钟，AHB时钟，APB2高速时钟，APB1低速时钟，这些时钟都是来源于SYSCLK系统时钟。其中以太网PTP时钟是使用系统时钟，AHB,APB2和APB1时钟是经过SYSCLK时钟分频得来，AHB最大时钟为168MHz, APB2高速时钟最大频率为84MHz,而APB1低速时钟最大频率为42MHz；</p>
<p><strong>STM32F4内部以太网MAC时钟的来源：</strong> 对于MII接口来说，必须向外部PHY芯片提供25Mhz的时钟，这个时钟，可以由PHY芯片外接晶振，或者使用STM32F4 的MCO输出来提供。然后，PHY 芯片再给STM32F4提供ETH_MII_TX_CLK和ETH_MII_RX_CLK时钟。对于RMII接口来说，外部必须提供50Mhz的时钟驱动PHY和STM32F4的ETH_RMII_REF_CLK，这个50Mhz时钟可以来自PHY、有源晶振或者STM32F4的MCO，<strong>开发板使用的是RMII 接口</strong>，使用PHY 芯片提供50Mhz时钟驱动STM32F4 的ETH_RMII_REF_CLK；</p>
<p><strong>外部PHY提供的USB OTG HS（60MHZ）时钟：</strong> F407 的USB 没有集成PHY，要想实现USB 高速传输的话，必须外置USB PHY 芯片，常用的芯片是USB3300。当外接USB PHY 芯片时，PHY 芯片需要给MCU 提供一个时钟；</p>
<h2 id="时钟初始化配置"><a class="markdownIt-Anchor" href="#时钟初始化配置"></a> 时钟初始化配置</h2>
<p>STM32F4时钟系统初始化是在system_stm32f4xx.c中的SystemInit()函数中完成的，总共6个步骤，<strong>初始化之后的状态：</strong></p>
<ul>
<li>SYSCLK（系统时钟）                            =168MHz</li>
<li>AHB总线时钟(HCLK=SYSCLK)              =168MHz</li>
<li>APB1总线时钟(PCLK1=SYSCLK/4)        =42MHz</li>
<li>APB2总线时钟(PCLK2=SYSCLK/2)        =84MHz</li>
<li>PLL主时钟	                                           =168MHz</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 使用HSE 时，设置系统时钟的步骤</span></span><br><span class="line"><span class="comment">* 1、开启HSE ，并等待 HSE 稳定</span></span><br><span class="line"><span class="comment">* 2、设置 AHB、APB2、APB1 的预分频因子</span></span><br><span class="line"><span class="comment">* 3、设置PLL 的时钟来源</span></span><br><span class="line"><span class="comment">*    设置VCO 输入时钟 分频因子 m</span></span><br><span class="line"><span class="comment">*    设置VCO 输出时钟 倍频因子 n</span></span><br><span class="line"><span class="comment">*    设置PLLCLK 时钟分频因子 p</span></span><br><span class="line"><span class="comment">*    设置OTG FS,SDIO,RNG 时钟分频因子 q</span></span><br><span class="line"><span class="comment">* 4、开启PLL，并等待PLL 稳定</span></span><br><span class="line"><span class="comment">* 5、把PLLCK 切换为系统时钟SYSCLK</span></span><br><span class="line"><span class="comment">* 6、读取时钟切换状态位，确保PLLCLK 被选为系统时钟</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL_M 25</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL_N 336</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL_P 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL_Q 7</span></span><br><span class="line"><span class="comment">// 要超频的话，修改PLL_N 这个宏即可，取值范围为：192~432。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetSysClock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__IO <span class="keyword">uint32_t</span> StartUpCounter = <span class="number">0</span>, HSEStatus = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1、使能HSE</span></span><br><span class="line">	RCC-&gt;CR |= ((<span class="keyword">uint32_t</span>)RCC_CR_HSEON);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待HSE 启动稳定</span></span><br><span class="line">	<span class="keyword">do</span> </span><br><span class="line">    &#123;</span><br><span class="line">		HSEStatus = RCC-&gt;CR &amp; RCC_CR_HSERDY;</span><br><span class="line">		StartUpCounter++;</span><br><span class="line">	&#125; <span class="keyword">while</span> ((HSEStatus==<span class="number">0</span>)&amp;&amp;(StartUpCounter!=HSE_STARTUP_TIMEOUT));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((RCC-&gt;CR &amp; RCC_CR_HSERDY) != RESET)</span><br><span class="line">    &#123;</span><br><span class="line">		HSEStatus = (<span class="keyword">uint32_t</span>)<span class="number">0x01</span>;</span><br><span class="line">	&#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">		HSEStatus = (<span class="keyword">uint32_t</span>)<span class="number">0x00</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// HSE 启动成功</span></span><br><span class="line">	<span class="keyword">if</span> (HSEStatus == (<span class="keyword">uint32_t</span>)<span class="number">0x01</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">// 调压器电压输出级别配置为1，以便在器件为最大频率</span></span><br><span class="line">		<span class="comment">// 工作时使性能和功耗实现平衡</span></span><br><span class="line">		RCC-&gt;APB1ENR |= RCC_APB1ENR_PWREN;</span><br><span class="line">		PWR-&gt;CR |= PWR_CR_VOS;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2、设置AHB/APB2/APB1 的分频因子</span></span><br><span class="line">		<span class="comment">// HCLK = SYSCLK / 1</span></span><br><span class="line">		RCC-&gt;CFGR |= RCC_CFGR_HPRE_DIV1;</span><br><span class="line">		<span class="comment">// PCLK2 = HCLK / 2</span></span><br><span class="line">		RCC-&gt;CFGR |= RCC_CFGR_PPRE2_DIV2;</span><br><span class="line">		<span class="comment">// PCLK1 = HCLK / 4</span></span><br><span class="line">		RCC-&gt;CFGR |= RCC_CFGR_PPRE1_DIV4;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3、配置主PLL 的时钟来源，设置M,N,P,Q</span></span><br><span class="line">		<span class="comment">// Configure the main PLL</span></span><br><span class="line">		RCC-&gt;PLLCFGR = PLL_M|(PLL_N&lt;&lt;<span class="number">6</span>)|(((PLL_P &gt;&gt; <span class="number">1</span>) <span class="number">-1</span>) &lt;&lt; <span class="number">16</span>) |(RCC_PLLCFGR_PLLSRC_HSE) |(PLL_Q &lt;&lt; <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 4、使能主PLL</span></span><br><span class="line">		RCC-&gt;CR |= RCC_CR_PLLON;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 等待PLL 稳定</span></span><br><span class="line">		<span class="keyword">while</span> ((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*----------------------------------------------------*/</span></span><br><span class="line">		<span class="comment">// 配置FLASH 预取指,指令缓存,数据缓存和等待状态</span></span><br><span class="line">		FLASH-&gt;ACR = FLASH_ACR_PRFTEN|FLASH_ACR_ICEN|FLASH_ACR_DCEN|FLASH_ACR_LATENCY_5WS;</span><br><span class="line">		<span class="comment">/*---------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 5、选择主PLLCLK 作为系统时钟源</span></span><br><span class="line">		RCC-&gt;CFGR &amp;= (<span class="keyword">uint32_t</span>)((<span class="keyword">uint32_t</span>)~(RCC_CFGR_SW));</span><br><span class="line">		RCC-&gt;CFGR |= RCC_CFGR_SW_PLL;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 6、读取时钟切换状态位，确保PLLCLK 选为系统时钟</span></span><br><span class="line">		<span class="keyword">while</span> ((RCC-&gt;CFGR &amp; (<span class="keyword">uint32_t</span>)RCC_CFGR_SWS )!= RCC_CFGR_SWS_PLL);</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">	<span class="comment">// HSE 启动出错处理</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="systeminit函数介绍"><a class="markdownIt-Anchor" href="#systeminit函数介绍"></a> SystemInit函数介绍</h2>
<p>在调用main函数前就会调用SystemInit函数，如果使用比较老的标准库，SystemInit要在主函数中调用，使用新的标准库都不需要再在主函数中调用，SystemInit函数完成系统的初始化，在下面代码标出主要进行哪些操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SystemInit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* FPU设置（浮点运算）*/</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> (__FPU_PRESENT == 1) &amp;&amp; (__FPU_USED == 1)</span></span><br><span class="line">    SCB-&gt;CPACR |= ((<span class="number">3UL</span> &lt;&lt; <span class="number">10</span>*<span class="number">2</span>)|(<span class="number">3UL</span> &lt;&lt; <span class="number">11</span>*<span class="number">2</span>));  <span class="comment">/* set CP10 and CP11 Full Access */</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="comment">/* 重置RCC时钟配置为默认配置*/</span></span><br><span class="line">  <span class="comment">/* 打开HSI时钟 */</span></span><br><span class="line">  RCC-&gt;CR |= (<span class="keyword">uint32_t</span>)<span class="number">0x00000001</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 重置CFGR寄存器 */</span></span><br><span class="line">  RCC-&gt;CFGR = <span class="number">0x00000000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 关闭HSEON, CSSON and PLLON时钟 */</span></span><br><span class="line">  RCC-&gt;CR &amp;= (<span class="keyword">uint32_t</span>)<span class="number">0xFEF6FFFF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 重置PLLCFGR寄存器 */</span></span><br><span class="line">  RCC-&gt;PLLCFGR = <span class="number">0x24003010</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 重置HSEBYP寄存器 */</span></span><br><span class="line">  RCC-&gt;CR &amp;= (<span class="keyword">uint32_t</span>)<span class="number">0xFFFBFFFF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 关闭所有中断 */</span></span><br><span class="line">  RCC-&gt;CIR = <span class="number">0x00000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (DATA_IN_ExtSRAM) || defined (DATA_IN_ExtSDRAM)</span></span><br><span class="line">  SystemInit_ExtMemCtl(); <span class="comment">//初始化外部存储器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* DATA_IN_ExtSRAM || DATA_IN_ExtSDRAM */</span></span></span><br><span class="line">         </span><br><span class="line">  <span class="comment">/* Configure the System clock source, PLL Multiplier and Divider factors, </span></span><br><span class="line"><span class="comment">     AHB/APBx prescalers and Flash settings ----------------------------------*/</span></span><br><span class="line">  SetSysClock();<span class="comment">//配置时钟，详细介绍参考时钟树章节</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Configure the Vector Table location add offset address ------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> VECT_TAB_SRAM</span></span><br><span class="line">  SCB-&gt;VTOR = SRAM_BASE | VECT_TAB_OFFSET; <span class="comment">/* Vector Table Relocation in Internal SRAM */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  SCB-&gt;VTOR = FLASH_BASE | VECT_TAB_OFFSET; <span class="comment">/* Vector Table Relocation in Internal FLASH */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="启动文件介绍"><a class="markdownIt-Anchor" href="#启动文件介绍"></a> 启动文件介绍</h2>
<p>启动文件由汇编编写，是系统上电复位后第一个执行的程序，<strong>主要做了以下工作：</strong></p>
<ol>
<li>初始化堆栈指针SP=_ initial_sp _</li>
<li>初始化PC 指针=Reset_Handler</li>
<li>初始化中断向量表</li>
<li>配置系统时钟</li>
<li>调用C 库函数_main 初始化用户堆栈，从而最终调用main 函数去到C 的世界</li>
</ol>
<h2 id="systick定时器"><a class="markdownIt-Anchor" href="#systick定时器"></a> Systick定时器</h2>
<p><strong>基础知识：</strong></p>
<p>Systick定时器，系统滴答定时器，是一个简单的定时器，对于CM3,CM4内核芯片，都有Systick定时器，Systick定时器常用来做延时，或者实时系统的心跳时钟，这样可以节省MCU资源，不用浪费一个定时器，比如UCOS中，分时复用，需要一个最小的时间戳，一般在STM32+UCOS系统中，都采用Systick做UCOS心跳时钟；</p>
<p>Systick定时器一个24 位的倒计数定时器，计到0 时，将从RELOAD 寄存器中自动重装载定时初值。只要不把它在SysTick 控制及状态寄存器中的使能位清除，就永不停息，即使在睡眠模式下也能工作；</p>
<p>SysTick定时器被捆绑在NVIC中，用于产生SYSTICK异常（异常号：15），Systick中断的优先级可以设置；</p>
<p>4个Systick寄存器：CTRL，LOAD，VAL，CALIB</p>
<p><strong>CTRL：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">位段</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">复位值</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">COUNTFLAG</td>
<td style="text-align:center">R</td>
<td style="text-align:center">0</td>
<td style="text-align:center">如果上次读取本寄存器后，Systick已经数到0，则该位为1.如果读取该位，该位自动清零</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">CLKSOURCE</td>
<td style="text-align:center">R/W</td>
<td style="text-align:center">0</td>
<td style="text-align:center">为0使用外部时钟源，为1使用内核时钟源</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">TICKINT</td>
<td style="text-align:center">R/W</td>
<td style="text-align:center">0</td>
<td style="text-align:center">为1，倒数到0时产生Systick异常请求，为0则倒数到0时无动作</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">ENABLE</td>
<td style="text-align:center">R/W</td>
<td style="text-align:center">0</td>
<td style="text-align:center">使能位</td>
</tr>
</tbody>
</table>
<p><strong>对于STM32，外部时钟源是 HCLK(AHB总线时钟）的1/8，内核时钟是 HCLK时钟</strong></p>
<p><strong>LOAD：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">位段</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">复位值</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">23：0</td>
<td style="text-align:center">RELOAD</td>
<td style="text-align:center">R/W</td>
<td style="text-align:center">0</td>
<td style="text-align:center">当倒数到0时，将被重装载的值</td>
</tr>
</tbody>
</table>
<p><strong>VAL：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">位段</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">复位值</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">23：0</td>
<td style="text-align:center">CURRENT</td>
<td style="text-align:center">R/W</td>
<td style="text-align:center">0</td>
<td style="text-align:center">读取时返回当前倒计数的值，写它则使之清零，同时还会清除在Systick控制及状态寄存器的COUNTFLAG标志</td>
</tr>
</tbody>
</table>
<p>Systick相关库函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SysTick_CLKSourceConfig() ;   <span class="comment">//Systick时钟源选择，在misc.c文件中（在SysTick_Config函数重新设置了CTRL的值，这个函数没用，要改时钟源修改SysTick_Config函数）</span></span><br><span class="line"></span><br><span class="line">SysTick_Config(<span class="keyword">uint32_t</span> ticks) ;<span class="comment">//初始化systick,时钟为HCLK,并开启中断,在core_cm3.h/core_cm4.h文件中，修改时钟源，中断优先级在这个函数修改  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_Handler</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//Systick中断服务函数</span></span><br></pre></td></tr></table></figure>
<p>使用Systick定时器中断方式实现跑马灯的延时：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;led.h&quot;</span></span></span><br><span class="line">u16 TimeDelay;<span class="comment">//定义全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 nTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//SysTick_CLKSourceConfig(ysTick_CLKSource_HCLK) ;//即使这里配置了时钟源，后面的SysTick_Config会重新配置，所以这句话在这个程序无效，要配置		时钟源需要修改SysTick_Config函数</span></span><br><span class="line">    SysTick_Config(<span class="number">168000</span>);<span class="comment">//默认设置了内核时钟源HCLK为Systick时钟，传的参数值-1相当传给VAL寄存器的值</span></span><br><span class="line">	TimeDelay=nTime;</span><br><span class="line">	<span class="keyword">while</span>(TimeDelay);<span class="comment">//当ntime不等于0时就卡在这里，等待SysTick_Handler中断服务函数将TimeDelay减为零就退出循环了，实现延时效果</span></span><br><span class="line">    SysTick-&gt;CTRL&amp;=~SysTick_CTRL_ENABLE_Msk;<span class="comment">//使用完后关闭Systick定时器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_Handler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(TimeDelay!=<span class="number">0x00</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		TimeDelay--;<span class="comment">//每产生一次中断减1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LED_Init();</span><br><span class="line">	<span class="keyword">for</span>(;;)</span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_SetBits(GPIOF,GPIO_Pin_9);</span><br><span class="line">		GPIO_ResetBits(GPIOF,GPIO_Pin_10);</span><br><span class="line">		delay(<span class="number">500</span>);</span><br><span class="line">		GPIO_ResetBits(GPIOF,GPIO_Pin_9);</span><br><span class="line">		GPIO_SetBits(GPIOF,GPIO_Pin_10);</span><br><span class="line">		delay(<span class="number">500</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="jlink在线调试软件调试方法与技巧"><a class="markdownIt-Anchor" href="#jlink在线调试软件调试方法与技巧"></a> JLINK在线调试+软件调试方法与技巧</h2>
<p><strong>JTAG/SWD调试原理：</strong> STM32F4xx的内核是CortexTM-M4F，该内核包含用于高级调试功能的硬件，利用这些调试功能，可以在取指（指令断点）或取访问数据（数据断点）时停止内核，内核停止时，可以查询内核的内部状态和系统的外部状态，查询完成后，将恢复内核和系统并恢复程序执行，当调试器与STM32F4xx MCU相连并进行调试时，将使用内核的硬件调试模块；</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rUCAfA"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/19/rUCAfA.png" alt="rUCAfA.png" /></a></p>
<p>如何复用 JTAG引脚</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rUCum8"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/19/rUCum8.png" alt="rUCum8.png" /></a></p>
<p>禁止JTAG-DP和SW-DP的库函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPIO_PinRemapConfig(GPIO_Remap_SWJ_Disable, ENABLE);<span class="comment">// 改变指定管脚的映射 GPIO_Remap_SWJ_Disable SWJ 完全禁用（JTAG+SW-DP）</span></span><br><span class="line">GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable , ENABLE);<span class="comment">// 改变指定管脚的映射 GPIO_Remap_SWJ_JTAGDisable ，JTAG-DP 禁用 + SW-DP 使能</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：复用后会导致无法使用JTAG/SWD模式下载程序，一般不会这样使用</strong></p>
<p>MDK调试模式下工具条各个图标的功能</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rUCo9A"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/19/rUCo9A.png" alt="rUCo9A.png" /></a></p>
<p>调试使用的快捷键和功能整体和VS差不多</p>
<p>在Peripheral工具栏可以查看寄存器，时钟等的值</p>
<h2 id="io引脚复用和映射"><a class="markdownIt-Anchor" href="#io引脚复用和映射"></a> IO引脚复用和映射</h2>
<p><strong>端口复用：</strong> STM32有很多的内置外设，这些外设的外部引脚都是与GPIO复用的。也就是说，一个GPIO如果可以复用为内置外设的功能引脚，那么当这个GPIO作为内置外设使用的时候，就叫做复用，例如串口1 的发送接收引脚是PA9,PA10，当我们把PA9,PA10不用作GPIO，而用做复用功能串口1的发送接收引脚的时候，叫端口复用，哪些引脚可以复用为哪些功能可以查询引脚分配表；</p>
<p><strong>STM32F4的端口复用映射原理：</strong> STM32F4系列微控制器IO引脚通过一个复用器连接到内置外设或模块，该复用器一次只允许一个外设的复用功能（AF）连接到对应的IO口，这样可以确保共用同一个IO引脚的外设之间不会发生冲突，每个IO引脚都有一个复用器，该复用器采用16路复用功能输入（AF0到AF15），可通过GPIOx_AFRL(针对引脚0-7)和GPIOx_AFRH（针对引脚8-15）寄存器对这些输入进行配置，每四位控制一路复用；</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rUiRFe"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/19/rUiRFe.jpg" alt="rUiRFe.jpg" /></a></p>
<p><strong>复用功能映射配置：</strong></p>
<ol>
<li>
<p><strong>系统功能</strong></p>
<p>将lO连接到AFO，然后根据所用功能进行配置:</p>
<ul>
<li>JTAG/SWD：在各器件复位后，会将这些引脚指定为专用引脚，可供片上调试模块立即使用（不受GPIO控制器控制）</li>
<li>RTC_REFIN：此引脚应配置为输入浮空模式</li>
<li>MCO1和MCO2:这些引脚必须配置为复用功能模式</li>
</ul>
</li>
<li>
<p><strong>GPIO</strong></p>
<p>在GPIO_MODER寄存器中将所需I/O配置为输入或输出</p>
</li>
<li>
<p><strong>外设复用功能</strong></p>
<p><strong>对于ADC和 DAC，在GPIOx_MODER寄存器中将所需IO配置为模拟通道</strong></p>
<p><strong>对于其它外设：</strong></p>
<ul>
<li>在GPIOx_MODER寄存器中将所需I/O配置为复用功能</li>
<li>通过GPIOx_OTYPER、GPIOx_PUPDR和GPIOx_OSPEEDER寄存器，分别选择类型、上拉/下拉以及输出速度</li>
<li>在GPIOx_AFRL 或GPIOx_AFRH寄存器中，将IO连接到所需AFx</li>
</ul>
</li>
</ol>
<p>以PA9,PA10复用为串口1的配置为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE); <span class="comment">//使能GPIOA时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);<span class="comment">//使能USART1时钟</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//USART1端口配置</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_10; <span class="comment">//GPIOA9与GPIOA10</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;<span class="comment">//复用功能 </span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	<span class="comment">//速度50MHz</span></span><br><span class="line">GPIO_InitStructure.GPIO_OType = GPIO_OType_PP; <span class="comment">//推挽复用输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP; <span class="comment">//上拉</span></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure); <span class="comment">//初始化PA9，PA10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//串口1对应引脚复用映射</span></span><br><span class="line">GPIO_PinAFConfig(GPIOA,GPIO_PinSource9,GPIO_AF_USART1); <span class="comment">//GPIOA9复用为USART1</span></span><br><span class="line">GPIO_PinAFConfig(GPIOA,GPIO_PinSource10,GPIO_AF_USART1); <span class="comment">//GPIOA10复用为USART1</span></span><br></pre></td></tr></table></figure>
<h2 id="nvic中断优先级管理"><a class="markdownIt-Anchor" href="#nvic中断优先级管理"></a> NVIC中断优先级管理</h2>
<p>STM32F4并没有使用CM4内核的全部东西，而是只用了它的一部分，STM32F40xx/STM32F41xx总共有92个中断，包括10个内核中断和82个可屏蔽中断，具有16级可编程的中断优先级，常见的内核中断包括复位(reset),不可屏蔽中断(NMI),硬错误(Hardfault)，而我们常用的就是这82个可屏蔽中断；</p>
<p><strong>中断管理方法：</strong> 对STM32中断进行分组，组0~4，同时，对每个中断设置一个抢占优先级和一个响应优先级值；</p>
<p>分组配置是在寄存器SCB-&gt;AIRCR中配置：</p>
<table>
<thead>
<tr>
<th style="text-align:center">组</th>
<th style="text-align:center">AIRCR[10:8]</th>
<th style="text-align:center">IP bit[7:4]分配情况</th>
<th style="text-align:center">分配结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">111</td>
<td style="text-align:center">0：4</td>
<td style="text-align:center">0位抢占优先级，4位响应优先级</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">110</td>
<td style="text-align:center">1：3</td>
<td style="text-align:center">1位抢占优先级，3位响应优先级</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">101</td>
<td style="text-align:center">2：2</td>
<td style="text-align:center">2位抢占优先级，2位响应优先级</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">100</td>
<td style="text-align:center">3：1</td>
<td style="text-align:center">3位抢占优先级，1位响应优先级</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">011</td>
<td style="text-align:center">4：0</td>
<td style="text-align:center">4位抢占优先级，0位响应优先级</td>
</tr>
</tbody>
</table>
<p><strong>抢占优先级 &amp; 响应优先级：</strong></p>
<ul>
<li>
<p>高优先级的抢占优先级是可以打断正在进行的低抢占优先级中断的</p>
</li>
<li>
<p>抢占优先级相同的中断，高响应优先级不可以打断低响应优先级的中断</p>
</li>
<li>
<p>抢占优先级相同的中断，当两个中断同时发生的情况下，哪个响应优先级高，哪个先执行</p>
</li>
<li>
<p>如果两个中断的抢占优先级和响应优先级都是一样的话，则看哪个中断先发生就先执行</p>
</li>
</ul>
<p>例如：设置中断优先级组为2，然后设置</p>
<p>中断3(RTC中断)的抢占优先级为2，响应优先级为1</p>
<p>中断6（外部中断0）的抢占优先级为3，响应优先级为0</p>
<p>中断7（外部中断1）的抢占优先级为2，响应优先级为0</p>
<p>那么这3个中断的优先级顺序为：中断7&gt;中断3&gt;中断6；</p>
<p><strong>一般情况下，系统代码执行过程中，只设置一次中断优先级分组，设置好分组之后一般不会再改变分组，随意改变分组会导致中断管理混乱，程序出现意想不到的执行结果；</strong></p>
<p><strong>优先级分组函数：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_PriorityGroupConfig</span><span class="params">(<span class="keyword">uint32_t</span> NVIC_PriorityGroup)</span></span>;<span class="comment">//设置分组2</span></span><br></pre></td></tr></table></figure>
<p><strong>中断初始化函数:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_Init</span><span class="params">(NVIC_InitTypeDef* NVIC_InitStruct)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint8_t</span> NVIC_IRQChannel; <span class="comment">//设置中断源</span></span><br><span class="line">  <span class="keyword">uint8_t</span> NVIC_IRQChannelPreemptionPriority;<span class="comment">//设置响应优先级</span></span><br><span class="line">  <span class="keyword">uint8_t</span> NVIC_IRQChannelSubPriority; <span class="comment">//设置抢占优先级</span></span><br><span class="line">  FunctionalState NVIC_IRQChannelCmd; <span class="comment">//使能/使能</span></span><br><span class="line">&#125; NVIC_InitTypeDef;</span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef   NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;<span class="comment">//串口1中断</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span> ;<span class="comment">// 抢占优先级为1</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">2</span>;<span class="comment">// 子优先级位2</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<span class="comment">//IRQ通道使能</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);	<span class="comment">//根据上面指定的参数初始化NVIC寄存器</span></span><br></pre></td></tr></table></figure>
<p><strong>中断优先级设置步骤:</strong></p>
<ol>
<li>
<p>系统运行后先设置中断优先级分组。调用函数：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_PriorityGroupConfig</span><span class="params">(<span class="keyword">uint32_t</span> NVIC_PriorityGroup)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>​	<strong>整个系统执行过程中，只设置一次中断分组</strong></p>
<ol start="2">
<li>
<p>针对每个中断，设置对应的抢占优先级和响应优先级：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_Init</span><span class="params">(NVIC_InitTypeDef* NVIC_InitStruct)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果需要挂起/解挂，查看中断当前激活状态，分别调用相关函数；</p>
</li>
</ol>
<h2 id="串口通信基本原理"><a class="markdownIt-Anchor" href="#串口通信基本原理"></a> 串口通信基本原理</h2>
<p><strong>处理器与外部设备通信的两种方式：</strong></p>
<p>并行通信：传输原理：数据各个位同时传输，优点：速度快，缺点：占用引脚资源多；</p>
<p>串行通信：传输原理：数据按位顺序传输，优点：占用引脚资源少，缺点：速度相对较慢；</p>
<p><strong>串行通信按照数据传送方向，分为：</strong></p>
<ul>
<li>单工： 数据传输只支持数据在一个方向上传输</li>
<li>半双工：允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信</li>
<li>全双工：允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立<br />
的接收和发送能力</li>
</ul>
<p><strong>串行通信的通信方式：</strong></p>
<p>同步通信：带时钟同步信号传输，SPI，IIC通信接口</p>
<p>异步通信：不带时钟同步信号，UART(通用异步收发器),单总线</p>
<p><strong>常见的串行通信接口：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">通信标准</th>
<th style="text-align:center">引脚说明</th>
<th style="text-align:center">通信方式</th>
<th style="text-align:center">通信方向</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">UART<br />（通用异步收发器）</td>
<td style="text-align:center">TXD：发送端<br />RXD：接收端<br />GND：公共端</td>
<td style="text-align:center">异步通信</td>
<td style="text-align:center">全双工</td>
</tr>
<tr>
<td style="text-align:center">单总线<br />（1-wire）</td>
<td style="text-align:center">DQ：发送/接收端</td>
<td style="text-align:center">异步通信</td>
<td style="text-align:center">半双工</td>
</tr>
<tr>
<td style="text-align:center">SPI</td>
<td style="text-align:center">SCK：同步时钟<br />MISO：主机输入，从机输出<br />MOSI：主机暑促，从机输入</td>
<td style="text-align:center">同步通信</td>
<td style="text-align:center">全双工</td>
</tr>
<tr>
<td style="text-align:center">I2C</td>
<td style="text-align:center">SCL：同步时钟<br />SDA：数据输入/输出端</td>
<td style="text-align:center">同步通信</td>
<td style="text-align:center">半双工</td>
</tr>
</tbody>
</table>
<p><strong>串口通信接口：</strong> USRT：通用异步收发器，USART：通用同步异步收发器；</p>
<p>USRT异步通信方式引脚连接方法：</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rDZnS0"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/22/rDZnS0.jpg" alt="rDZnS0.jpg" /></a></p>
<p>哪些引脚可以复用为USRT/USART可通过原理图、数据手册或引脚分配表查询；</p>
<p><strong>串口通信过程：</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rDZx74"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/22/rDZx74.jpg" alt="rDZx74.jpg" /></a></p>
<p><strong>串口通信框图：</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rDMdXt"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/22/rDMdXt.jpg" alt="rDMdXt.jpg" /></a></p>
<p><strong>串口异步通信需要定义的参数：</strong></p>
<ul>
<li>起始位</li>
<li>数据位（8或带奇偶校验位9位）</li>
<li>奇偶校验位（第9位，可以没有，奇偶是指前面数据位中1的个数是奇数还是偶数，奇偶校验位通过加0或加1的方式保证数据位的1的个数是奇数或者偶数）</li>
<li>停止位（1，2，,5，15位）</li>
<li>波特率设置</li>
</ul>
<h2 id="串口寄存器和库函数配置"><a class="markdownIt-Anchor" href="#串口寄存器和库函数配置"></a> 串口寄存器和库函数配置</h2>
<p><strong>常用的串口相关寄存器：</strong></p>
<ul>
<li>USART_SR  状态寄存器</li>
<li>USART_DR  数据寄存器</li>
<li>USART_BSR 波特率寄存器</li>
</ul>
<p><strong>串口操作相关库函数：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略了参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_Init</span><span class="params">()</span></span>; <span class="comment">//串口初始化：波特率，数据字长，奇偶校验，硬件流控以及收发使能</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_Cmd</span><span class="params">()</span></span>;<span class="comment">//使能串口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_ITConfig</span><span class="params">()</span></span>;<span class="comment">//使能相关中断</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_SendData</span><span class="params">()</span></span>;<span class="comment">//发送数据到串口，DR</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">USART_ReceiveData</span><span class="params">()</span></span>;<span class="comment">//接受数据，从DR读取接受到的数据</span></span><br><span class="line"></span><br><span class="line"><span class="function">FlagStatus <span class="title">USART_GetFlagStatus</span><span class="params">()</span></span>;<span class="comment">//获取状态标志位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_ClearFlag</span><span class="params">()</span></span>;<span class="comment">//清除状态标志位</span></span><br><span class="line"><span class="function">ITStatus <span class="title">USART_GetITStatus</span><span class="params">()</span></span>;<span class="comment">//获取中断状态标志位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_ClearITPendingBit</span><span class="params">()</span></span>;<span class="comment">//清除中断状态标志位</span></span><br></pre></td></tr></table></figure>
<p>波特率的计算：</p>
<p>假设串口要设置115200的波特率，PLCK的时钟（即APB2总线时钟频率）为84M，则</p>
<p>USARTDIV=84000000/(115200*16)=45.572</p>
<p>那么</p>
<p>DIV_Fraction=16*0.572=8=0x09;</p>
<p>DIV_Mantissa=45=0x2d;</p>
<p>硬件连接：PA9，PA10（串口1）连接到了USB串口电路；</p>
<p><strong>串口配置的一般步骤：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RCC_APBxPeriphClockCmd();<span class="comment">//1.串口时钟使能,GPIO时钟使能</span></span><br><span class="line">RCC_AHB1PeriphClockCmd();</span><br><span class="line">GPIO_PinAFConfig();<span class="comment">//2.引脚复用映射</span></span><br><span class="line">GPIO_Init();<span class="comment">//3.GPIO端口模式设置,模式设置为GPIO_Mode_AF</span></span><br><span class="line">USART_Init();<span class="comment">//4.串口参数初始化</span></span><br><span class="line">NVIC_Init();<span class="comment">//5.开启中断并且初始化NVIC（如果需要开启中断才需要这个步骤）</span></span><br><span class="line">USART_ITConfig();</span><br><span class="line">USART_Cmd();<span class="comment">//6.使能串口</span></span><br><span class="line">USARTx_IRQHandler();<span class="comment">//7.编写中断处理函数</span></span><br><span class="line"><span class="comment">//8.串口数据收发</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_SendData</span><span class="params">()</span></span>;<span class="comment">//发送数据到串口，DR</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">USART_ReceiveData</span><span class="params">()</span></span>;<span class="comment">//接受数据，从DR读取接受到的数据</span></span><br><span class="line"><span class="comment">//9.串口传输状态获取：</span></span><br><span class="line"><span class="function">FlagStatus <span class="title">USART_GetFlagStatus</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_ClearITPendingBit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>简单串口实验：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//usrt.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _USRT_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _USRT_H_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyUSRT_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usrt.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//设置中断优先级分组</span></span><br><span class="line">	MyUSRT_Init();<span class="comment">//串口初始化</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);<span class="comment">//死循环，等待发生串口中断，执行中断服务函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//usrt.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usrt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyUSRT_Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	USART_InitTypeDef USART_Init_Structure;<span class="comment">//定义一个串口初始化结构体</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitTypeDef_Structure;<span class="comment">//定义一个GPIO初始化结构体</span></span><br><span class="line">	NVIC_InitTypeDef NVIC_InitTypeDef_Structure;<span class="comment">//定义一个中断初始化结构体</span></span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);<span class="comment">//使能串口时钟</span></span><br><span class="line">	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA ,ENABLE);<span class="comment">//使能GPIO时钟</span></span><br><span class="line">	</span><br><span class="line">	GPIO_PinAFConfig(GPIOA,GPIO_PinSource9,GPIO_AF_USART1);<span class="comment">//设置9，10引脚复用为串口</span></span><br><span class="line">	GPIO_PinAFConfig(GPIOA,GPIO_PinSource10,GPIO_AF_USART1);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef_Structure.GPIO_Mode=GPIO_Mode_AF;<span class="comment">//设置为复用模式</span></span><br><span class="line">	GPIO_InitTypeDef_Structure.GPIO_Pin=GPIO_Pin_9|GPIO_Pin_10;<span class="comment">//9和10引脚</span></span><br><span class="line">	GPIO_InitTypeDef_Structure.GPIO_PuPd=GPIO_PuPd_UP;<span class="comment">//设置上拉模式</span></span><br><span class="line">	GPIO_InitTypeDef_Structure.GPIO_Speed=GPIO_High_Speed;<span class="comment">//设置传输速度</span></span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitTypeDef_Structure);<span class="comment">//初始化GPIO</span></span><br><span class="line">	</span><br><span class="line">	USART_Init_Structure.USART_BaudRate=<span class="number">115200</span>;<span class="comment">//设置波特率</span></span><br><span class="line">	USART_Init_Structure.USART_HardwareFlowControl=USART_HardwareFlowControl_None;<span class="comment">//关闭硬件流控制</span></span><br><span class="line">	USART_Init_Structure.USART_Mode=USART_Mode_Rx|USART_Mode_Tx;<span class="comment">//设置发送和接受模式</span></span><br><span class="line">	USART_Init_Structure.USART_Parity=USART_Parity_No;<span class="comment">//设置没有奇偶校验</span></span><br><span class="line">	USART_Init_Structure.USART_StopBits=USART_StopBits_1;<span class="comment">//设置停止位为1位</span></span><br><span class="line">	USART_Init_Structure.USART_WordLength=USART_WordLength_8b;<span class="comment">//设置数据位为8位</span></span><br><span class="line">	USART_Init(USART1,&amp;USART_Init_Structure);</span><br><span class="line">	</span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannel=USART1_IRQn;<span class="comment">//设置中断通道，产生什么中断</span></span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannelCmd=ENABLE;<span class="comment">//使能中断</span></span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;<span class="comment">//设置抢占优先级</span></span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;<span class="comment">//设置响应优先级</span></span><br><span class="line">	NVIC_Init(&amp;NVIC_InitTypeDef_Structure);<span class="comment">//初始化中断</span></span><br><span class="line">	</span><br><span class="line">	USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//设置中断触发方式</span></span><br><span class="line">	USART_Cmd(USART1,ENABLE);<span class="comment">//使能串口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART1_IRQHandler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 res;</span><br><span class="line">	<span class="keyword">if</span>(USART_GetFlagStatus(USART1,USART_FLAG_RXNE))</span><br><span class="line">	&#123;</span><br><span class="line">		res=USART_ReceiveData(USART1);</span><br><span class="line">		USART_SendData(USART1,res);<span class="comment">//接受到什么数据，就将什么数据再发送出去</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="串口通信实验"><a class="markdownIt-Anchor" href="#串口通信实验"></a> 串口通信实验</h2>
<p><strong>usart.c实现的相关协议：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USART_REC_LEN   200  	<span class="comment">//定义最大接收字节数 </span></span></span><br><span class="line">u8  USART_RX_BUF[USART_REC_LEN];<span class="comment">//接收缓冲,最大USART_REC_LEN个字节.末字节为换行符</span></span><br><span class="line">u16 USART_RX_STA;         		<span class="comment">//接收状态标记	</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">USART_RX_STA</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bit15</td>
<td style="text-align:center">bit14</td>
<td style="text-align:center">bit13~0</td>
</tr>
<tr>
<td style="text-align:center">接收完成标志</td>
<td style="text-align:center">接收到0X0D标志</td>
<td style="text-align:center">接收到的有效数据个数</td>
</tr>
</tbody>
</table>
<p>接收到0x0d和0x0a表示所有数据接受完成</p>
<p>实现代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART1_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 Res;</span><br><span class="line">	<span class="keyword">if</span>(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)<span class="comment">//接收完成一个字节数据产生中断</span></span><br><span class="line">	&#123;</span><br><span class="line">		Res =USART_ReceiveData(USART1);<span class="comment">//接收数据传给RES</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>((USART_RX_STA&amp;<span class="number">0x8000</span>)==<span class="number">0</span>)<span class="comment">//如果未接收完</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(USART_RX_STA&amp;<span class="number">0x4000</span>)<span class="comment">//如果上一次接受到了0x0d</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(Res!=<span class="number">0x0a</span>) USART_RX_STA=<span class="number">0</span>;<span class="comment">//没有接收到0x0a表示并不是接收完成标志</span></span><br><span class="line">				<span class="keyword">else</span> USART_RX_STA|=<span class="number">0x8000</span>;<span class="comment">//接收到了0x0a，数据接收完成</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;	</span><br><span class="line">				<span class="keyword">if</span>(Res==<span class="number">0x0d</span>) USART_RX_STA|=<span class="number">0x4000</span>;<span class="comment">//接收到了0x0d</span></span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					USART_RX_BUF[USART_RX_STA&amp;<span class="number">0X3FFF</span>]=Res ;<span class="comment">//将接收到的数据缓存到数组</span></span><br><span class="line">					USART_RX_STA++;</span><br><span class="line">					<span class="keyword">if</span>(USART_RX_STA&gt;(USART_REC_LEN<span class="number">-1</span>)) USART_RX_STA=<span class="number">0</span>; </span><br><span class="line">				&#125;		 </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;   		 </span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>
<p><strong>串口通信实验：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 t=<span class="number">0</span>;</span><br><span class="line">	u8 len;</span><br><span class="line">	u16 times;</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">	delay_init(<span class="number">168</span>);</span><br><span class="line">	uart_init(<span class="number">115200</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(USART_RX_STA&amp;<span class="number">0x8000</span>)<span class="comment">//接收完成了</span></span><br><span class="line">		&#123;</span><br><span class="line">			len=USART_RX_STA&amp;<span class="number">0x3fff</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\r\n发送的消息为:\r\n&quot;</span>);<span class="comment">//打印（发送）“发送的消息为”到串口</span></span><br><span class="line">			<span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;len;t++)</span><br><span class="line">			&#123;</span><br><span class="line">				USART_SendData(USART1,USART_RX_BUF[t]);<span class="comment">//发送接收到的数据到串口</span></span><br><span class="line">				<span class="keyword">while</span>(USART_GetFlagStatus(USART1,USART_FLAG_TC)!=SET);<span class="comment">//等待发送完成</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">			USART_RX_STA=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			times++;</span><br><span class="line">			<span class="keyword">if</span>(times%<span class="number">5000</span>==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;\r\nALIENTEK 探索者开发板 串口实验\r\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;正点原子@ALIENTEK\r\n\r\n\r\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(times%<span class="number">1000</span>==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;请输入数据，以回车键结束\r\n&quot;</span>);  </span><br><span class="line">			delay_ms(<span class="number">10</span>);   </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="外部中断实验"><a class="markdownIt-Anchor" href="#外部中断实验"></a> 外部中断实验</h2>
<p>STM32F4的每个IO都可以作为外部中断输入</p>
<p>STM32F4的中断控制器支持<strong>22个外部中断/事件请求：</strong><br />
EXTI线0~15：对应外部IO口的输入中断</p>
<p>EXTI线16：连接到PVD输出<br />
EXTI线17：连接到RTC闹钟事件<br />
EXTI线18：连接到USB OTG FS唤醒事件<br />
EXTI线19：连接到以太网唤醒事件<br />
EXTI线20：连接到USB OTG HS(在FS中配置)唤醒事件<br />
EXTI线21：连接到RTC入侵和时间戳事件<br />
EXTI线22：连接到RTC唤醒事件</p>
<p>每个外部中断线可以独立的配置触发方式（上升沿，下降沿或者双边沿触发），触发/屏蔽，专用的状态位；</p>
<p>从上面可以看出，STM32F4<strong>供IO使用的中断线只有16个</strong> ，STM32F4xx系列的IO口多达上百个，</p>
<p><strong>中断线怎么跟io口对应：</strong></p>
<p>GPIOx.0映射到EXTI0</p>
<p>GPIOx.1映射到EXTI1</p>
<p>…</p>
<p>GPIOx.15映射到EXTI15</p>
<p>对于每个中断线，我们可以设置相应的触发方式（上升沿触发，下降沿触发，边沿触发）以及使能；</p>
<p>IO口外部中断在中断向量表中只分配了7个中断向量，也就是只能使用7个中断服务函数</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rsyhtO"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/23/rsyhtO.png" alt="rsyhtO.png" /></a></p>
<p>外部中断线5 ~ 9分配一个中断向量，共用一个服务函数外部中断线10 ~  15分配一个中断向量，共用一个中断服务函数；</p>
<p>EXTI框图</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/r5ZlLD"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/27/r5ZlLD.png" alt="r5ZlLD.png" /></a></p>
<p><strong>中断服务函数列表：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXTI0_IRQHandler           </span><br><span class="line">EXTI1_IRQHandler</span><br><span class="line">EXTI2_IRQHandler           </span><br><span class="line">EXTI3_IRQHandler           </span><br><span class="line">EXTI4_IRQHandler           </span><br><span class="line">EXTI9_5_IRQHandler         </span><br><span class="line">EXTI15_10_IRQHandler</span><br></pre></td></tr></table></figure>
<p><strong>常用外部中断库函数：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SYSCFG_EXTILineConfig</span><span class="params">(<span class="keyword">uint8_t</span> EXTI_PortSourceGPIOx, <span class="keyword">uint8_t</span> EXTI_PinSourcex)</span></span>;<span class="comment">//设置IO口与中断线的映射关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_Init</span><span class="params">(EXTI_InitTypeDef* EXTI_InitStruct)</span></span>;<span class="comment">//初始化中断线：触发方式等</span></span><br><span class="line"><span class="function">ITStatus <span class="title">EXTI_GetITStatus</span><span class="params">(<span class="keyword">uint32_t</span> EXTI_Line)</span></span>;<span class="comment">//判断中断线中断状态，是否发生</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_ClearITPendingBit</span><span class="params">(<span class="keyword">uint32_t</span> EXTI_Line)</span></span>;<span class="comment">//清除中断线上的中断标志位</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);<span class="comment">//使能SYSCFG时钟,非常重要，在使用外部中断的时候一定要先使能SYSCFG时钟</span></span><br></pre></td></tr></table></figure>
<p><strong>EXTI_Init函数：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_Init</span><span class="params">(EXTI_InitTypeDef* EXTI_InitStruct)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> EXTI_Line;   <span class="comment">//指定要配置的中断线           </span></span><br><span class="line">  EXTIMode_TypeDef EXTI_Mode;   <span class="comment">//模式：事件 OR中断</span></span><br><span class="line">  EXTITrigger_TypeDef EXTI_Trigger;<span class="comment">//触发方式：上升沿/下降沿/双沿触发</span></span><br><span class="line">  FunctionalState EXTI_LineCmd;  <span class="comment">//使能 OR失能</span></span><br><span class="line">&#125;EXTI_InitTypeDef;</span><br></pre></td></tr></table></figure>
<p><strong>外部中断的一般配置步骤：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);<span class="comment">//1.使能SYSCFG时钟</span></span><br><span class="line">GPIO_Init();<span class="comment">//2.初始化IO口为输入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SYSCFG_EXTILineConfig</span><span class="params">()</span></span>;<span class="comment">//设置IO口与中断线的映射关系</span></span><br><span class="line">EXTI_Init();<span class="comment">//初始化线上中断，设置触发条件等</span></span><br><span class="line">NVIC_Init();<span class="comment">//配置中断分组（NVIC），并使能中断</span></span><br><span class="line">EXTIx_IRQHandler();<span class="comment">//编写中断服务函数</span></span><br><span class="line">EXTI_ClearITPendingBit();<span class="comment">//清除中断标志位</span></span><br></pre></td></tr></table></figure>
<p>按键硬件连接：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/16/r1v9pj.png" alt="r1v9pj.png" /></p>
<p><strong>外部中断实验：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;beep.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;exti.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//中断优先级分组2</span></span><br><span class="line">	delay_init(<span class="number">168</span>);</span><br><span class="line">	LED_Init();</span><br><span class="line">	BEEP_Init();</span><br><span class="line">	EXTIX_Init();<span class="comment">//外部中断初始化</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//exti.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;exti.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;beep.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI0_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//按下WKUP键LED0反转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	delay_ms(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span>(WK_UP==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LED0=!LED0;</span><br><span class="line">	&#125;</span><br><span class="line">	EXTI_ClearITPendingBit(EXTI_Line0);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI2_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//按下KEY2键LED1反转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	delay_ms(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span>(KEY_2==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LED1=!LED1;</span><br><span class="line">	&#125;</span><br><span class="line">	EXTI_ClearITPendingBit(EXTI_Line2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI3_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//按下KEY1键蜂鸣器反转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	delay_ms(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span>(KEY_1==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		BEEP=!BEEP;</span><br><span class="line">	&#125;</span><br><span class="line">	EXTI_ClearITPendingBit(EXTI_Line3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI4_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//按下KEY0键LED0，1都反转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	delay_ms(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span>(KEY_0==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LED0=!LED0;</span><br><span class="line">		LED1=!LED1;</span><br><span class="line">	&#125;</span><br><span class="line">	EXTI_ClearITPendingBit(EXTI_Line4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//exti.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTIX_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitTypeDef_Structure;<span class="comment">//定义初始化结构体</span></span><br><span class="line">	EXTI_InitTypeDef EXTI_InitTypeDef_Structure;</span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG,ENABLE);<span class="comment">//使能SYSCFG时钟</span></span><br><span class="line">	</span><br><span class="line">	KEY_Init();<span class="comment">//初始化key对应GPIO</span></span><br><span class="line">	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOE,EXTI_PinSource2);</span><br><span class="line">	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOE,EXTI_PinSource3);</span><br><span class="line">	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOE,EXTI_PinSource4);</span><br><span class="line">	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOA,EXTI_PinSource0);</span><br><span class="line">	</span><br><span class="line">	EXTI_InitTypeDef_Structure.EXTI_Line=EXTI_Line2|EXTI_Line3|EXTI_Line4;</span><br><span class="line">	EXTI_InitTypeDef_Structure.EXTI_LineCmd=ENABLE;</span><br><span class="line">	EXTI_InitTypeDef_Structure.EXTI_Mode=EXTI_Mode_Interrupt;</span><br><span class="line">	EXTI_InitTypeDef_Structure.EXTI_Trigger=EXTI_Trigger_Falling;</span><br><span class="line">	EXTI_Init(&amp;EXTI_InitTypeDef_Structure);</span><br><span class="line">	</span><br><span class="line">	EXTI_InitTypeDef_Structure.EXTI_Line=EXTI_Line0;</span><br><span class="line">	EXTI_InitTypeDef_Structure.EXTI_LineCmd=ENABLE;</span><br><span class="line">	EXTI_InitTypeDef_Structure.EXTI_Mode=EXTI_Mode_Interrupt;</span><br><span class="line">	EXTI_InitTypeDef_Structure.EXTI_Trigger=EXTI_Trigger_Rising;</span><br><span class="line">	EXTI_Init(&amp;EXTI_InitTypeDef_Structure);<span class="comment">//初始化按键对应GPIO的EXTI</span></span><br><span class="line">	</span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannel=EXTI0_IRQn;</span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;</span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitTypeDef_Structure);</span><br><span class="line">	</span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannel=EXTI2_IRQn;</span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannelPreemptionPriority=<span class="number">2</span>;</span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitTypeDef_Structure);</span><br><span class="line">	</span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannel=EXTI3_IRQn;</span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannelPreemptionPriority=<span class="number">3</span>;</span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitTypeDef_Structure);</span><br><span class="line">	</span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannel=EXTI4_IRQn;</span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannelPreemptionPriority=<span class="number">4</span>;</span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitTypeDef_Structure);<span class="comment">//中断优先级初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="基本定时器原理"><a class="markdownIt-Anchor" href="#基本定时器原理"></a> 基本定时器原理</h2>
<p><strong>定时器功能：</strong> 定时、输出比较、输入捕获、互补输出；</p>
<p><strong>定时器分类：</strong> 基本定时器、通用定时器、高级定时器；</p>
<p><strong>定时器资源：</strong> 407有2个高级定时器、10个通用定时器、2个基本定时器</p>
<p><strong>各个定时器特性：</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/r7E4u6"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/28/r7E4u6.png" alt="r7E4u6.png" /></a></p>
<p><strong>基本定时器特点：</strong></p>
<ul>
<li>计数器16bit，只能向上计数，只有TIM6和TIM7</li>
<li>没有外部的GPIO，是内部资源，只能用来定时</li>
<li>时钟来自PCLK1，可实现1~65536分频</li>
</ul>
<p><strong>基本定时器功能框图：</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/r7meqP"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/28/r7meqP.png" alt="r7meqP.png" /></a></p>
<p>分三个部分：1.时钟源，2.控制器，3.计数器</p>
<p>时钟源来自RCC的TIMx_CLK (属于内部的CK_INT)</p>
<p><strong>TIMx_CLK怎么看是多少：</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/r7nnyR"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/28/r7nnyR.jpg" alt="r7nnyR.jpg" /></a></p>
<p>先看定时器挂在哪个时钟上，基本定时器是挂载在APB1上的，分频系数是4，168/4=42M，如果分频系数是1，则总线时钟就等于APB1，如果分频系数不是1，则乘以2，这里分频系数是4，所以是乘以2，得到TIMx_CLK时钟是42*2=84M</p>
<p>控制器用于控制定时器的：复位、使能、计数、触发DAC，涉及到的寄存器为：CR1/2、DIER、EGR、SR；</p>
<p><strong>定时器最主要的就是时基部分：</strong> 包括 预分频器、计数器、自动重装载寄存器</p>
<p><strong>预分频器：16位的预分频器TIMx_PSC对内部时钟CK_INT进行分频之后，得到计数器时钟CK_CNT=CK_PSC/PSC+1</strong></p>
<p><strong>计数器CNT在计数器时钟的驱动下开始计数，计数一次的时间为1/CK_CNT</strong></p>
<p><strong>计数器、自动重装载寄存器：</strong> 定时器使能(CEN 置 1)后，计数器 CNT在CK_CNT 驱动下向上计数，当 TIMx_CNT 值与 TIMx_ARR 的设定值相等时就自动生成事件并 TIMx_CNT 自动清零，然后自动重新开始计数，如此重复以上过程</p>
<p><strong>影子寄存器：</strong> PSC和ARR都有影子寄存器，功能框图上有个影子<br />
影子寄存器的存在<strong>起到一个缓冲的作用</strong> ，用户值-&gt;寄存器-&gt;影子寄存器-&gt;起作用，如果不使用影子寄存器则用户值在写到寄存器之后则里面起作用<br />
ARR影子，TIMx_CR1:APRE位控制</p>
<p><strong>如何实现定时0.5s：</strong></p>
<p>方法：先固定一个值再求另一个值，一般让频率分频后=10^nHz，然后计数器的值就比较容易看，比如让频率为10KHz</p>
<p>PSC = 8400-1，定时器频率=84M/(PSC+1)=10000HZ<br />
ARR = 4999，从0计数到4999，则计了5000次<br />
T = 5000 /  10000 = 0.5S</p>
<h2 id="基本定时器中断实验"><a class="markdownIt-Anchor" href="#基本定时器中断实验"></a> 基本定时器中断实验</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;timx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;led.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LED_Init();</span><br><span class="line">	TIMX_Init();</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//timx.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;timx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIMX_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitTypeDef_Structure;</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitTypeDef_Structure;</span><br><span class="line">	</span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM7,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//TIM_TimeBaseInitTypeDef_Structure.TIM_ClockDivision=  //基本定时器没有外部时钟分频因子，不用设置</span></span><br><span class="line">	<span class="comment">//TIM_TimeBaseInitTypeDef_Structure.TIM_CounterMode=TIM_CounterMode_Up;//基本定时器只能向上计数，默认就是向上，不用设置</span></span><br><span class="line">	TIM_TimeBaseInitTypeDef_Structure.TIM_Period=<span class="number">5000</span><span class="number">-1</span>;<span class="comment">//设置自动重装载值</span></span><br><span class="line">	TIM_TimeBaseInitTypeDef_Structure.TIM_Prescaler=<span class="number">8400</span><span class="number">-1</span>;<span class="comment">//设置预分频因子</span></span><br><span class="line">	<span class="comment">//TIM_TimeBaseInitTypeDef_Structure.TIM_RepetitionCounter=//基本定时器没有重复计数器，只有高级定时器有，不用设置</span></span><br><span class="line">	TIM_TimeBaseInit(TIM7,&amp;TIM_TimeBaseInitTypeDef_Structure);<span class="comment">//初始化定时器</span></span><br><span class="line">	</span><br><span class="line">	TIM_ITConfig(TIM7,TIM_IT_Update,ENABLE); <span class="comment">//使能定时器中断</span></span><br><span class="line">	TIM_Cmd(TIM7,ENABLE); <span class="comment">//使能定时器</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannel=TIM7_IRQn; <span class="comment">//设置中断源</span></span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannelPreemptionPriority=<span class="number">0x01</span>; <span class="comment">//设置抢占优先级</span></span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannelSubPriority=<span class="number">0x03</span>; <span class="comment">//设置响应优先级</span></span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitTypeDef_Structure);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM7_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(TIM_GetITStatus(TIM7,TIM_IT_Update)==SET)</span><br><span class="line">	&#123;</span><br><span class="line">		LED0=!LED0;</span><br><span class="line">		LED1=!LED1;</span><br><span class="line">	&#125;</span><br><span class="line">	TIM_ClearITPendingBit(TIM7,TIM_IT_Update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="通用定时器原理"><a class="markdownIt-Anchor" href="#通用定时器原理"></a> 通用定时器原理</h2>
<p>STM32F40x系列总共最多有<strong>14个定时器，12个16位，2个32位（只有通用定时器有）</strong> ；</p>
<p><strong>三种定时器区别：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>定时器种类</strong></th>
<th style="text-align:center"><strong>位数</strong></th>
<th style="text-align:center"><strong>计数器模式</strong></th>
<th style="text-align:center"><strong>产生DMA请求</strong></th>
<th style="text-align:center"><strong>捕获/比较通道</strong></th>
<th style="text-align:center"><strong>互补输出</strong></th>
<th style="text-align:center"><strong>特殊应用场景</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">高级定时器  （TIM1,TIM8)</td>
<td style="text-align:center">16</td>
<td style="text-align:center">向上，向下，向上/下</td>
<td style="text-align:center">可以</td>
<td style="text-align:center">4</td>
<td style="text-align:center">有</td>
<td style="text-align:center">带可编程死区的互补输出</td>
</tr>
<tr>
<td style="text-align:center">通用定时器（TIM2,TIM5）</td>
<td style="text-align:center">32</td>
<td style="text-align:center">向上，向下，向上/下</td>
<td style="text-align:center">可以</td>
<td style="text-align:center">4</td>
<td style="text-align:center">无</td>
<td style="text-align:center">通用。定时计数，PWM输出，输入捕获，输出比较</td>
</tr>
<tr>
<td style="text-align:center">通用定时器（TIM3,TIM4）</td>
<td style="text-align:center">16</td>
<td style="text-align:center">向上，向下，向上/下</td>
<td style="text-align:center">可以</td>
<td style="text-align:center">4</td>
<td style="text-align:center">无</td>
<td style="text-align:center">通用。定时计数，PWM输出，输入捕获，输出比较</td>
</tr>
<tr>
<td style="text-align:center">通用定时器（TIM9~TIM14）</td>
<td style="text-align:center">16</td>
<td style="text-align:center">向上</td>
<td style="text-align:center">没有</td>
<td style="text-align:center">2</td>
<td style="text-align:center">无</td>
<td style="text-align:center">通用。定时计数，PWM输出，输入捕获，输出比较</td>
</tr>
<tr>
<td style="text-align:center">基本定时器  (TIM6,TIM7)</td>
<td style="text-align:center">16</td>
<td style="text-align:center">向上，向下，向上/下</td>
<td style="text-align:center">可以</td>
<td style="text-align:center">0</td>
<td style="text-align:center">无</td>
<td style="text-align:center">主要应用于驱动DAC</td>
</tr>
</tbody>
</table>
<p><strong>通用定时器功能特点：</strong></p>
<ul>
<li>16 /32 位向上、向下、向上/向下(中心对齐)计数模式，自动装载计数器（TIMx_CNT）</li>
<li>16 位可编程(可以实时修改)预分频器(TIMx_PSC)，计数器时钟频率的分频系数 为 1～65535 之间的任意数值</li>
<li>4 个独立通道（TIMx_CH1~4），这些通道可以用来作为： 输入捕获 ，输出比较，PWM 生成(边缘或中间对齐模式) ，单脉冲模式输出</li>
<li>可使用外部信号（TIMx_ETR）控制定时器和定时器互连（可以用 1 个定时器控制另外一个定时器）的同步电路</li>
</ul>
<p><strong>产生中断/DMA的条件：</strong></p>
<ul>
<li>更新：计数器溢出，计数器初始化；</li>
<li>触发事件(计数器启动、停止、初始化或者由内部/外部触发计数)</li>
<li>输入捕获</li>
<li>输出比较</li>
<li>支持针对定位的增量(正交)编码器和霍尔传感器电路</li>
<li>触发输入作为外部时钟或者按周期的电流管理</li>
</ul>
<p><strong>通用定时器可以被用于：</strong> 测量输入信号的脉冲长度(输入捕获)或者产生输出波形(输出比较和 PWM)等</p>
<p>STM32 的每个通用定时器都是完全独立的，没有互相共享的任何资源；</p>
<p>计数器模式：向上计数，向下计数，中心对齐，图形表示</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/r5neij"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/27/r5neij.png" alt="r5neij.png" /></a></p>
<p>定时器框图</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/r5uJnf"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/27/r5uJnf.jpg" alt="r5uJnf.jpg" /></a></p>
<p>计数器时钟有8种选择</p>
<p>更新事件：将预载寄存器的内容写入影子寄存器（通过自动重载位是否被使能来决定），不使用影子寄存器则立即，使用则在每次更新事件发生时</p>
<p>产生更新事件的条件：</p>
<ul>
<li>当计数器上溢或者下溢时</li>
<li>当循环计数器计数值为0时（TIM1）</li>
<li>通过软件设置UG（Update Generation）位</li>
</ul>
<p>更新事件的请求源可以从下面选择</p>
<ul>
<li>URS=1 仅当计数器到达上溢/下溢时，将发出更新请求</li>
<li>URS=0 计数器的上溢/下溢、更新位的设置或从模式控制器产生的更新，将发出更新请求</li>
</ul>
<h2 id="通用定时器中断实验"><a class="markdownIt-Anchor" href="#通用定时器中断实验"></a> 通用定时器中断实验</h2>
<p>计数器时钟可以由下列时钟源提供：</p>
<ul>
<li>内部时钟(CK_INT)</li>
<li>外部时钟模式1：外部输入脚(TIx)</li>
<li>外部时钟模式2：外部触发输入(ETR) (仅适用TIM2,3,4)</li>
<li>内部触发输入(ITRx)：使用一个定时器作为另一个定时器的预分频器，如可以配置一个定时器Timer1而作为另一个定时器Timer2的预分频器</li>
</ul>
<p><strong>内部时钟选择：</strong> 除非APB1的分频系数是1，否则通用定时器的时钟等于APB1时钟的2倍；</p>
<p>计数器模式：通用定时器可以向上计数、向下计数、向上向下双向计数模式；</p>
<p>常用寄存器：</p>
<ul>
<li>计数器当前值寄存器CNT</li>
<li>预分频寄存器TIMx_PSC</li>
<li>自动重装载寄存器（TIMx_ARR)</li>
<li>控制寄存器1（TIMx_CR1）</li>
<li>DMA中断使能寄存器（TIMx_DIER）</li>
</ul>
<p><strong>常用库函数：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在stm32f4xx_tim.c/.h中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_TimeBaseInit</span><span class="params">(TIM_TypeDef* TIMx,TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)</span></span>;<span class="comment">//定时器参数初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_Cmd</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span></span>;<span class="comment">//定时器使能函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ITConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_IT, FunctionalState NewState)</span></span>;<span class="comment">//定时器中断使能</span></span><br><span class="line"><span class="comment">//几个状态标志位获取和清除函数</span></span><br><span class="line"><span class="function">FlagStatus <span class="title">TIM_GetFlagStatus</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_FLAG)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ClearFlag</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_FLAG)</span></span>;</span><br><span class="line"><span class="function">ITStatus <span class="title">TIM_GetITStatus</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_IT)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ClearITPendingBit</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_IT)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>定时器中断实现步骤：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB1PeriphClockCmd();<span class="comment">//1.使能定时器时钟</span></span><br><span class="line">TIM_TimeBaseInit();<span class="comment">//2.初始化定时器，配置ARR,PSC</span></span><br><span class="line">NVIC_Init();<span class="comment">//3.开启定时器中断，配置NVIC</span></span><br><span class="line">TIM_Cmd();<span class="comment">//4.使能定时器</span></span><br><span class="line">TIMx_IRQHandler();<span class="comment">//5.编写中断服务函数</span></span><br></pre></td></tr></table></figure>
<p><strong>实验代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;timx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;led.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LED_Init();</span><br><span class="line">	TIMX_Init();</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//timx.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;timx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIMX_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitTypeDef_Structure;</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitTypeDef_Structure;</span><br><span class="line">	</span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//TIM_TimeBaseInitTypeDef_Structure.TIM_ClockDivision=</span></span><br><span class="line">	TIM_TimeBaseInitTypeDef_Structure.TIM_CounterMode=TIM_CounterMode_Up;</span><br><span class="line">	TIM_TimeBaseInitTypeDef_Structure.TIM_Period=<span class="number">5000</span><span class="number">-1</span>;</span><br><span class="line">	TIM_TimeBaseInitTypeDef_Structure.TIM_Prescaler=<span class="number">8400</span><span class="number">-1</span>;</span><br><span class="line">	<span class="comment">//TIM_TimeBaseInitTypeDef_Structure.TIM_RepetitionCounter=</span></span><br><span class="line">	TIM_TimeBaseInit(TIM3,&amp;TIM_TimeBaseInitTypeDef_Structure);</span><br><span class="line">	</span><br><span class="line">	TIM_ITConfig(TIM3,TIM_IT_Update,ENABLE); </span><br><span class="line">	TIM_Cmd(TIM3,ENABLE); </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannel=TIM3_IRQn; </span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannelPreemptionPriority=<span class="number">0x01</span>; </span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannelSubPriority=<span class="number">0x03</span>; </span><br><span class="line">	NVIC_InitTypeDef_Structure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitTypeDef_Structure);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM3_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(TIM_GetITStatus(TIM3,TIM_IT_Update)==SET)</span><br><span class="line">	&#123;</span><br><span class="line">		LED0=!LED0;</span><br><span class="line">		LED1=!LED1;</span><br><span class="line">	&#125;</span><br><span class="line">	TIM_ClearITPendingBit(TIM3,TIM_IT_Update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高级定时器实验"><a class="markdownIt-Anchor" href="#高级定时器实验"></a> 高级定时器实验</h2>
<h2 id="pwm输出实验"><a class="markdownIt-Anchor" href="#pwm输出实验"></a> PWM输出实验</h2>
<p>PWM输出配置过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.使能定时器14和相关IO口时钟。</span></span><br><span class="line">RCC_APB1PeriphClockCmd();<span class="comment">//使能定时器14时钟</span></span><br><span class="line">RCC_AHB1PeriphClockCmd ();<span class="comment">//使能GPIOF时钟</span></span><br><span class="line"><span class="comment">//2.初始化IO口为复用功能输出</span></span><br><span class="line">GPIO_Init();</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;<span class="comment">//复用功能</span></span><br><span class="line"><span class="comment">//3.GPIOF复用映射到定时器</span></span><br><span class="line">GPIO_PinAFConfig(GPIOF,GPIO_PinSource9,GPIO_AF_TIM14); 	</span><br><span class="line"><span class="comment">//4.初始化定时器：ARR,PSC等：</span></span><br><span class="line">TIM_TimeBaseInit();</span><br><span class="line"><span class="comment">//初始化输出比较参数</span></span><br><span class="line">TIM_OC1Init();</span><br><span class="line"><span class="comment">//6.使能预装载寄存器 </span></span><br><span class="line">TIM_OC1PreloadConfig(TIM14, TIM_OCPreload_Enable); </span><br><span class="line"><span class="comment">//7.使能自动重装载的预装载寄存器允许位</span></span><br><span class="line">TIM_ARRPreloadConfig(TIM14,ENABLE);</span><br><span class="line"><span class="comment">//8.使能定时器。</span></span><br><span class="line"><span class="comment">//9.不断改变比较值CCRx，达到不同的占空比效果</span></span><br><span class="line">TIM_SetCompare1();</span><br></pre></td></tr></table></figure>
<h2 id="输入捕获实验"><a class="markdownIt-Anchor" href="#输入捕获实验"></a> 输入捕获实验</h2>
<h2 id="tft-lcd显示实验"><a class="markdownIt-Anchor" href="#tft-lcd显示实验"></a> TFT LCD显示实验</h2>
<p>几个常用的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCD_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//初始化LCD</span></span><br><span class="line">void LCD_Clear(u16 color)；//清屏填充色</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCD_ShowChar</span><span class="params">(u16 x,u16 y,u8 num,u8 size,u8 mode)</span></span>;<span class="comment">//显示字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCD_ShowxNum</span><span class="params">(u16 x,u16 y,u32 num,u8 len,u8 size,u8 mode)</span></span>;<span class="comment">//显示数字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCD_ShowString</span><span class="params">(u16 x,u16 y,u16 width,u16 height,u8 size,u8 *p)</span></span>;<span class="comment">//显示字符串</span></span><br><span class="line"></span><br><span class="line">POINT_COLOR=RED;<span class="comment">//画笔颜色设置红色   </span></span><br></pre></td></tr></table></figure>
<p>实验代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;lcd.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> 	u8 x=<span class="number">0</span>;</span><br><span class="line">	u8 lcd_id[<span class="number">12</span>];				</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">	delay_init(<span class="number">168</span>);     </span><br><span class="line">	uart_init(<span class="number">115200</span>);		</span><br><span class="line">	</span><br><span class="line">	LED_Init();					  </span><br><span class="line"> 	LCD_Init();          </span><br><span class="line">	POINT_COLOR=RED;<span class="comment">//画笔颜色设置红色   </span></span><br><span class="line">	<span class="built_in">sprintf</span>((<span class="keyword">char</span>*)lcd_id,<span class="string">&quot;LCD ID:%04X&quot;</span>,lcddev.id);	</span><br><span class="line">  	<span class="keyword">while</span>(<span class="number">1</span>) </span><br><span class="line">	&#123;		 </span><br><span class="line">		<span class="keyword">switch</span>(x)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:LCD_Clear(WHITE);<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:LCD_Clear(BLACK);<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:LCD_Clear(BLUE);<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:LCD_Clear(RED);<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>:LCD_Clear(MAGENTA);<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>:LCD_Clear(GREEN);<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">6</span>:LCD_Clear(CYAN);<span class="keyword">break</span>; </span><br><span class="line">			<span class="keyword">case</span> <span class="number">7</span>:LCD_Clear(YELLOW);<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">8</span>:LCD_Clear(BRRED);<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">9</span>:LCD_Clear(GRAY);<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">10</span>:LCD_Clear(LGRAY);<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">11</span>:LCD_Clear(BROWN);<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		POINT_COLOR=RED;	  </span><br><span class="line">		LCD_ShowString(<span class="number">30</span>,<span class="number">40</span>,<span class="number">210</span>,<span class="number">24</span>,<span class="number">24</span>,<span class="string">&quot;Explorer STM32F4&quot;</span>);	</span><br><span class="line">		LCD_ShowString(<span class="number">30</span>,<span class="number">70</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;TFTLCD TEST&quot;</span>);</span><br><span class="line">		LCD_ShowString(<span class="number">30</span>,<span class="number">90</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,<span class="string">&quot;ATOM@ALIENTEK&quot;</span>);</span><br><span class="line"> 		LCD_ShowString(<span class="number">30</span>,<span class="number">110</span>,<span class="number">200</span>,<span class="number">16</span>,<span class="number">16</span>,lcd_id);			 </span><br><span class="line">		LCD_ShowString(<span class="number">30</span>,<span class="number">130</span>,<span class="number">200</span>,<span class="number">12</span>,<span class="number">12</span>,<span class="string">&quot;2014/5/4&quot;</span>);	      					 </span><br><span class="line">	  	x++;</span><br><span class="line">		<span class="keyword">if</span>(x==<span class="number">12</span>)x=<span class="number">0</span>;</span><br><span class="line">		LED0=!LED0;	 </span><br><span class="line">		delay_ms(<span class="number">1000</span>);	</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="485通信实验"><a class="markdownIt-Anchor" href="#485通信实验"></a> 485通信实验</h2>
<h2 id="i2c实验"><a class="markdownIt-Anchor" href="#i2c实验"></a> I2C实验</h2>
<h2 id="mpu6050实验"><a class="markdownIt-Anchor" href="#mpu6050实验"></a> MPU6050实验</h2>
<h2 id="spi实验"><a class="markdownIt-Anchor" href="#spi实验"></a> SPI实验</h2>
<h2 id="24g无线通信实验"><a class="markdownIt-Anchor" href="#24g无线通信实验"></a> 2.4G无线通信实验</h2>
<h2 id="oled显示实验"><a class="markdownIt-Anchor" href="#oled显示实验"></a> OLED显示实验</h2>
<p>几个常用的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void OLED_Init(void)；//初始化OLED</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OLED_Refresh_Gram</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//更新显存到LCD,每次更新显存数据就调用该函数来显示</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OLED_ShowNum</span><span class="params">(u8 x,u8 y,u32 num,u8 len,u8 size)</span></span>;<span class="comment">//显示数字，x，y为起点坐标，num是要显示的数字，len表示数字的位数，size表示字体大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OLED_ShowString</span><span class="params">(u8 x,u8 y,<span class="keyword">const</span> u8 *p,u8 size)</span></span>;<span class="comment">//显示字符串，x，y为起点坐标，size表示字体大小，p是字符串首地址</span></span><br></pre></td></tr></table></figure>
<p>实验代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;oled.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	u8 t=<span class="number">0</span>;</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">	delay_init(<span class="number">168</span>);     </span><br><span class="line">	uart_init(<span class="number">115200</span>);	</span><br><span class="line">	LED_Init();					</span><br><span class="line"> 	OLED_Init();				</span><br><span class="line">    OLED_ShowString(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;ALIENTEK&quot;</span>,<span class="number">24</span>);  </span><br><span class="line">	OLED_ShowString(<span class="number">0</span>,<span class="number">24</span>, <span class="string">&quot;0.96&#x27; OLED TEST&quot;</span>,<span class="number">16</span>);  </span><br><span class="line"> 	OLED_ShowString(<span class="number">0</span>,<span class="number">40</span>,<span class="string">&quot;ATOM 2014/5/4&quot;</span>,<span class="number">12</span>);  </span><br><span class="line"> 	OLED_ShowString(<span class="number">0</span>,<span class="number">52</span>,<span class="string">&quot;ASCII:&quot;</span>,<span class="number">12</span>);  </span><br><span class="line"> 	OLED_ShowString(<span class="number">64</span>,<span class="number">52</span>,<span class="string">&quot;CODE:&quot;</span>,<span class="number">12</span>);  </span><br><span class="line">	OLED_Refresh_Gram();</span><br><span class="line">	t=<span class="string">&#x27; &#x27;</span>;  </span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) </span><br><span class="line">	&#123;		</span><br><span class="line">		OLED_ShowChar(<span class="number">36</span>,<span class="number">52</span>,t,<span class="number">12</span>,<span class="number">1</span>);</span><br><span class="line">		OLED_ShowNum(<span class="number">94</span>,<span class="number">52</span>,t,<span class="number">3</span>,<span class="number">12</span>);</span><br><span class="line">		OLED_Refresh_Gram();        </span><br><span class="line">		t++;</span><br><span class="line">		<span class="keyword">if</span>(t&gt;<span class="string">&#x27;~&#x27;</span>)t=<span class="string">&#x27; &#x27;</span>;  </span><br><span class="line">		delay_ms(<span class="number">500</span>);</span><br><span class="line">		LED0=!LED0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="can实验"><a class="markdownIt-Anchor" href="#can实验"></a> CAN实验</h2>
<h2 id="硬件随机数发生器"><a class="markdownIt-Anchor" href="#硬件随机数发生器"></a> 硬件随机数发生器</h2>
<p>STM32F4自带了硬件随机数发生器（RNG），RNG处理器是一个以连续模拟噪声为基础的随机数发生器，在主机读数时<strong>提供一个32位的随机数</strong> ；</p>
<p>两个连续的随机数的间隔为<strong>40个PLL48CLK时钟信号周期</strong> ；</p>
<p>通过监控RNG熵来标识异常行为；</p>
<p>可以禁止来降低功耗；</p>
<p>STM32F4的随机数发生器（RNG）采用模拟电路实现，此电路产生馈入线性反馈移位寄存器 (RNG_LFSR) 的种子，用于生成 32 位随机数；</p>
<p>该模拟电路由几个环形振荡器组成，振荡器的输出进行异或运算以产生种子，RNG_LFSR 由专用时钟 (PLL48CLK) 按恒定频率提供时钟信息，因此<strong>随机数质量与 HCLK 频率无关</strong> 。当将大量种子引入RNG_LFSR后，RNG_LFSR 的内容会传入数据寄存器 (RNG_DR)。</p>
<p>同时，系统会监视模拟种子和专用时钟 PLL48CLK，当种子上出现异常序列，或PLL48CLK时钟频率过低时，可以由RNG_SR寄存器的对应位读取到，如果<strong>设置了中断</strong> ，则在检测到错误时，还<strong>可以产生中断</strong></p>
<p><strong>随机数发生器框图：</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/ry226g"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/23/ry226g.png" alt="ry226g.png" /></a></p>
<p><strong>RNG寄存器：</strong></p>
<ol>
<li>控制寄存器RNG_CR</li>
<li>状态寄存器RNG_SR</li>
<li>数据寄存器RNG_DR</li>
</ol>
<p>RNG库函数（在stm32f4xx_rng.h/stm32f4xx_rng.c）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RNG_DeInit</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//复位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RNG_Cmd</span><span class="params">(FunctionalState NewState)</span></span>;<span class="comment">//使能RNG</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">RNG_GetRandomNumber</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//获取随机数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RNG_ITConfig</span><span class="params">(FunctionalState NewState)</span></span>;</span><br><span class="line"><span class="function">FlagStatus <span class="title">RNG_GetFlagStatus</span><span class="params">(<span class="keyword">uint8_t</span> RNG_FLAG)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RNG_ClearFlag</span><span class="params">(<span class="keyword">uint8_t</span> RNG_FLAG)</span></span>;</span><br><span class="line"><span class="function">ITStatus <span class="title">RNG_GetITStatus</span><span class="params">(<span class="keyword">uint8_t</span> RNG_IT)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RNG_ClearITPendingBit</span><span class="params">(<span class="keyword">uint8_t</span> RNG_IT)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="窗口看门狗实验"><a class="markdownIt-Anchor" href="#窗口看门狗实验"></a> 窗口看门狗实验</h2>
<p>之所以称为窗口就是因为其喂狗时间是一个有上下限的范围内(窗口），可以通过设定相关寄存器，设定其上限时间（下限固定），喂狗的时间不能过早也不能过晚，而独立看门狗限制喂狗时间在0-x内，x由相关寄存器决定。喂狗的时间不能过晚；</p>
<p>STM32F的窗口看门狗中有一个<strong>7位的递减计数器T[6:0]</strong> ，它会在出现下述<strong>2种情况之一时产生看门狗复位：</strong></p>
<ol>
<li>当喂狗的时候如果计数器的值大于某一设定数值W[6:0]时，此设定数值在WWDG_CFR寄存器定义；</li>
<li>当计数器的数值从0x40减到0x3F时【T6位跳变到0】；</li>
</ol>
<p>如果启动了看门狗并且允许中断，当递减计数器等于0x40时产生早期唤醒中断（EWI),它可以用于喂狗以避免WWDG复位；</p>
<p><strong>窗口看门狗超时时间：</strong></p>
<p><strong>为什么要窗口看门狗？</strong></p>
<p>对于一般的看门狗，程序可以在它产生复位前的任意时刻刷新看门狗，但这有一个隐患，有可能程序跑乱了又跑回到正常的地方，或跑乱的程序正好执行了刷新看门狗操作，这样的情况下一般的看门狗就检测不出来了；</p>
<p>如果使用窗口看门狗，程序员可以根据程序正常执行的时间设置刷新看门狗的一个时间窗口，保证不会提前刷新看门狗也不会滞后刷新看门狗，这样可以检测出程序没有按照正常的路径运行非正常地跳过了某些程序段的情况</p>
<p><strong>窗口看门狗其他注意事项：</strong></p>
<ol>
<li>上窗口值W[6:0]必须大于下窗口值0x40。否则就无窗口了；</li>
<li>窗口看门狗时钟来源PCLK1（APB1总线时钟）分频后；</li>
</ol>
<p><strong>常用寄存器：</strong></p>
<p><strong>窗口看门狗配置过程：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB1PeriphClockCmd();<span class="comment">//1.使能看门狗时钟</span></span><br><span class="line">WWDG_SetPrescaler();<span class="comment">//2.设置分频系数</span></span><br><span class="line">WWDG_SetWindowValue();<span class="comment">//3.设置上窗口值</span></span><br><span class="line">WWDG_EnableIT();<span class="comment">//4.开启提前唤醒中断并分组(可选)</span></span><br><span class="line">NVIC_Init();</span><br><span class="line">WWDG_Enable();<span class="comment">//5.使能看门狗</span></span><br><span class="line">WWDG_SetCounter();<span class="comment">//6.喂狗</span></span><br><span class="line">WWDG_IRQHandler();<span class="comment">//7.编写中断服务函数</span></span><br></pre></td></tr></table></figure>
<h2 id="独立看门狗实验"><a class="markdownIt-Anchor" href="#独立看门狗实验"></a> 独立看门狗实验</h2>
<p>由于单片机的工作常常会受到来自外界电磁场的干扰，造成程序的跑飞，而陷入死循环，程序的正常运行被打断，由单片机控制的系统无法继续工作，会造成整个系统的陷入停滞状态，发生不可预料的后果，<strong>用于监测单片机程序运行状态的模块或者芯片</strong> ，俗称“看门狗”(watchdog)</p>
<p><strong>看门狗解决的问题：</strong> 在启动正常运行的时候，系统不能复位，在系统跑飞（程序异常执行）的情况，系统复位，程序重新执行；</p>
<p>STM32内置两个看门狗，两个看门狗设备（独立看门狗/窗口看门狗)可以用来检测和解决由软件错误引起的故障，当计数器达到给定的超时值时，触发一个<br />
中断（仅适用窗口看门狗）或者产生系统复位；</p>
<p><strong>独立看门狗（IWDG)由专用的低速时钟（LSI)驱动</strong> ，即使主时钟发生故障它仍有效，独立看门狗适合应用于需要看门狗作为一个在主程序之外 能够完全独立工</p>
<p>作，并且<strong>对时间精度要求低的场合</strong> ；</p>
<p><strong>窗口看门狗由从APB1时钟分频后得到时钟驱动</strong> ，通过可配置的时间窗口来检测应用程序非正常的过迟或过早操作，窗口看门狗最适合那些<strong>要求看门狗在精确计时窗口起作用的程序</strong> ；</p>
<p><strong>独立看门狗功能描述：<strong>在键值寄存器</strong>（IWDG_KR)中写入0xCCCC</strong> ，开始启用独立看门狗。此时计数器开始从其复位值0xFFF递减，当计数器值计数<strong>到尾值0x000时会产生一个复位信号（IWDG_RESET)</strong> 。<br />
无论何时，只要<strong>在键值寄存器IWDG_KR中写入0xAAAA（通常说的喂狗）</strong> , 自动重装载寄存器IWDG_RLR的值就会重新加载到计数器，从而避免看门狗复位。<br />
如果程序异常，就无法正常喂狗，从而系统复位；</p>
<p><strong>相关寄存器：</strong></p>
<ul>
<li>键值寄存器IWDG_KR: 0~15位有效，只写寄存器，读出值为0x0000，软件必须以一定时间间隔写入0xAAAA，否则，计数值为0时，看门狗会产生复位</li>
<li>预分频寄存器IWDG_PR：0~2位有效，具有写保护功能，要操作先取消写保护，读值时要保证状态寄存器的PVU位为0，读值才有效</li>
<li>重装载寄存器IWDG_RLR：0~11位有效，具有写保护功能，要操作先取消写保护，只有当状态寄存器的RVU位为0时，才能对寄存器进行修改，读出的值才有效</li>
<li>状态寄存器IWDG_SR：0~1位有效，RVU为1表示重装载值的更新正在进行中，更新结束会由硬件清零，为0时才能修改重装载寄存器的值，PVU则控制预分频寄存器，和RVU逻辑一样；</li>
</ul>
<p>独立看门狗超时时间：</p>
<p><strong>IWDG独立看门狗操作库函数：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IWDG_WriteAccessCmd</span><span class="params">(<span class="keyword">uint16_t</span> IWDG_WriteAccess)</span></span>;<span class="comment">//取消写保护：0x5555使能</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IWDG_SetPrescaler</span><span class="params">(<span class="keyword">uint8_t</span> IWDG_Prescaler)</span></span>;<span class="comment">//设置预分频系数：写PR</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IWDG_SetReload</span><span class="params">(<span class="keyword">uint16_t</span> Reload)</span></span>;<span class="comment">//设置重装载值：写RLR</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IWDG_ReloadCounter</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//喂狗：写0xAAAA到KR</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IWDG_Enable</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//使能看门狗：写0xCCCC到KR</span></span><br><span class="line"><span class="function">FlagStatus <span class="title">IWDG_GetFlagStatus</span><span class="params">(<span class="keyword">uint16_t</span> IWDG_FLAG)</span></span>;<span class="comment">//状态：重装载/预分频 更新</span></span><br></pre></td></tr></table></figure>
<p><strong>独立看门狗操作步骤：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IWDG_WriteAccessCmd();<span class="comment">//1.取消寄存器写保护</span></span><br><span class="line">IWDG_SetPrescaler();<span class="comment">//2.设置独立看门狗的预分频系数，确定时钟</span></span><br><span class="line">IWDG_SetReload();<span class="comment">//3.设置看门狗重装载值，确定溢出时间</span></span><br><span class="line">IWDG_Enable();<span class="comment">//4.使能看门狗</span></span><br><span class="line">IWDG_ReloadCounter();<span class="comment">//5.应用程序喂狗</span></span><br></pre></td></tr></table></figure>
<h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2>
<h2 id="待机唤醒实验"><a class="markdownIt-Anchor" href="#待机唤醒实验"></a> 待机唤醒实验</h2>
<p>很多单片机有低功耗模式，STM32也不例外，在系统或者电源复位后，微控制器出于运行状态之下，HCLK为CPU提供时钟，内核执行代码，当CPU不需要继续运行时，可以利用多种低功耗模式来节省功耗，例如等待某个事件触发；</p>
<p><strong>STM32的3种低功耗模式：</strong></p>
<ol>
<li>睡眠模式：内核停止，外设如NVIC，系统时钟Systick仍运行；</li>
<li>停止模式：所有时钟都已停止。1.8V内核电源工作，PLL,HIS和HSE RC振荡器功能禁止，寄存器和SRAM内容保留；</li>
<li>待机模式：1.8V内核电源关闭，只有备份寄存器和待机电路维持供电，寄存器和SRAM内容全部丢失。实现最低功耗；</li>
</ol>
<p><strong>STM32F4的3种低功耗模式：</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rcIkDK"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/24/rcIkDK.png" alt="rcIkDK.png" /></a></p>
<p><strong>STM32F4的待机模式：</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/rcIhKx"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2020/12/24/rcIhKx.png" alt="rcIhKx.png" /></a></p>
<p>待机模式理想状态下，只需要2.2uA电流。停机模式下典型电流为350uA；</p>
<p>对于使能了RTC闹钟中断或RTC周期性唤醒等中断的时候，进入待机模式前，必须按如下操作处理:</p>
<ol>
<li>禁止RTC中断（ALRAIE、ALRBIE、WUTIE、TAMPIE和TSIE等)；</li>
<li>清零对应中断标志位；</li>
<li>清除PWR唤醒(WUF)标志（通过设置PWR_CR的CWUF位实现)；</li>
<li>重新使能RTC对应中断；</li>
<li>进入低功耗模式；</li>
<li>在有用到RTC相关中断的时候，必须按以上步骤执行之后，才可以进入待机模式，否则可能无法唤醒；</li>
</ol>
<p><strong>低功耗操作函数：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件：stm32f4xx_pwr.c  / stm32f4xx_pwr.h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PWR_EnterSTOPMode</span><span class="params">()</span></span>;<span class="comment">//进入停机模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PWR_EnterSTANDBYMode</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//进入待机模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PWR_WakeUpPinCmd</span><span class="params">(FunctionalState NewState)</span></span>;<span class="comment">//使能Wakeup引脚唤醒</span></span><br><span class="line"><span class="function">FlagStatus <span class="title">PWR_GetFlagStatus</span><span class="params">(<span class="keyword">uint32_t</span> PWR_FLAG)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PWR_ClearFlag</span><span class="params">(<span class="keyword">uint32_t</span> PWR_FLAG)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件： core_cm4.h</span></span><br><span class="line">__WFI() ;</span><br><span class="line">__WFE() ;</span><br></pre></td></tr></table></figure>
<p><strong>待机唤醒配置步骤：</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.使能电源时钟,因为要配置电源控制寄存器，所以必须先使能电源时钟</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);</span><br><span class="line"><span class="comment">//2.RTC相关处理：关闭RTC相关中断</span></span><br><span class="line"><span class="comment">//3.设置WK_UP引脚作为唤醒源,设置PWR_CSR的EWUP位，使能WK_UP用于将CPU从待机模式唤醒。</span></span><br><span class="line">PWR_WakeUpPinCmd(ENABLE);  <span class="comment">//使能唤醒管脚功能</span></span><br><span class="line"><span class="comment">//4.设置SLEEPDEEP位，设置PDDS位，执行WFI指令，进入待机模式</span></span><br><span class="line">void PWR_EnterSTANDBYMode(void)；</span><br></pre></td></tr></table></figure>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/STM32/">STM32</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/letanga/MyPictureBed/img/src=http---file2.dzsc.com-data-18-01-26-111730918.png&amp;refer=http---file2.dzsc.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2017/10/04/%E7%94%B5%E9%98%BB%E7%94%B5%E5%AE%B9%E7%94%B5%E6%84%9F%E9%80%89%E5%9E%8B/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2021/03/01/6ieMFI.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">电阻电容电感选型</div></div></a></div><div class="next-post pull-right"><a href="/2017/09/05/%E5%B0%8F%E7%B1%B3%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/letanga/MyPictureBed/img/20210601015610.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">小米手机刷机</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/01/04/DIY STM32F103ZET6开发板/" title="DIY STM32F103ZET6开发板"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/letanga/MyPictureBed/img/src=http---hbimg.b0.upaiyun.com-89220c7fb5f05a43cc05dadf8b17891bf0d10b3c64b50-yi5NeT_fw658&refer=http---hbimg.b0.upaiyun.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-04</div><div class="title">DIY STM32F103ZET6开发板</div></div></a></div><div><a href="/2018/01/06/DIY STM32小四轴飞行器/" title="DIY STM32小四轴飞行器"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/letanga/MyPictureBed/img/20210601010944.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-01-06</div><div class="title">DIY STM32小四轴飞行器</div></div></a></div><div><a href="/2018/03/04/DIY STM32平衡小车/" title="DIY STM32平衡小车"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/letanga/MyPictureBed/img/20210601223739.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-03-04</div><div class="title">DIY STM32平衡小车</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/letanga/MyPictureBed/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Darren</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/letanga"><i class="fab fa-github"></i><span>关注 Follow</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/letanga" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:247022864@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://blog.csdn.net/lemea" target="_blank" title="CSDN博客"><i class="fas fa-blog"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">这是我的个人博客<br>如果IE或其他浏览器显示混乱需要更换浏览器</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text"> 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E6%9D%BF%E8%B5%84%E6%BA%90"><span class="toc-number">2.</span> <span class="toc-text"> 开发板资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%AF%86"><span class="toc-number">3.</span> <span class="toc-text"> 一些常识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%8B%E8%BD%BD"><span class="toc-number">4.</span> <span class="toc-text"> 程序下载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF"><span class="toc-number">5.</span> <span class="toc-text"> 工程模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpio%E5%8E%9F%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text"> GPIO原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%91%E9%A9%AC%E7%81%AF%E5%AE%9E%E9%AA%8C"><span class="toc-number">7.</span> <span class="toc-text"> 跑马灯实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%9C%82%E9%B8%A3%E5%99%A8%E5%AE%9E%E9%AA%8C"><span class="toc-number">8.</span> <span class="toc-text"> 蜂鸣器实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5%E5%AE%9E%E9%AA%8C"><span class="toc-number">9.</span> <span class="toc-text"> 按键输入实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E6%A0%91"><span class="toc-number">10.</span> <span class="toc-text"> 时钟树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE"><span class="toc-number">11.</span> <span class="toc-text"> 时钟初始化配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#systeminit%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D"><span class="toc-number">12.</span> <span class="toc-text"> SystemInit函数介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="toc-number">13.</span> <span class="toc-text"> 启动文件介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#systick%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">14.</span> <span class="toc-text"> Systick定时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jlink%E5%9C%A8%E7%BA%BF%E8%B0%83%E8%AF%95%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7"><span class="toc-number">15.</span> <span class="toc-text"> JLINK在线调试+软件调试方法与技巧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E5%BC%95%E8%84%9A%E5%A4%8D%E7%94%A8%E5%92%8C%E6%98%A0%E5%B0%84"><span class="toc-number">16.</span> <span class="toc-text"> IO引脚复用和映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nvic%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7%E7%AE%A1%E7%90%86"><span class="toc-number">17.</span> <span class="toc-text"> NVIC中断优先级管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">18.</span> <span class="toc-text"> 串口通信基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0%E9%85%8D%E7%BD%AE"><span class="toc-number">19.</span> <span class="toc-text"> 串口寄存器和库函数配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E5%AE%9E%E9%AA%8C"><span class="toc-number">20.</span> <span class="toc-text"> 串口通信实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C"><span class="toc-number">21.</span> <span class="toc-text"> 外部中断实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9A%E6%97%B6%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-number">22.</span> <span class="toc-text"> 基本定时器原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C"><span class="toc-number">23.</span> <span class="toc-text"> 基本定时器中断实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-number">24.</span> <span class="toc-text"> 通用定时器原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C"><span class="toc-number">25.</span> <span class="toc-text"> 通用定时器中断实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E9%AA%8C"><span class="toc-number">26.</span> <span class="toc-text"> 高级定时器实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwm%E8%BE%93%E5%87%BA%E5%AE%9E%E9%AA%8C"><span class="toc-number">27.</span> <span class="toc-text"> PWM输出实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E5%AE%9E%E9%AA%8C"><span class="toc-number">28.</span> <span class="toc-text"> 输入捕获实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tft-lcd%E6%98%BE%E7%A4%BA%E5%AE%9E%E9%AA%8C"><span class="toc-number">29.</span> <span class="toc-text"> TFT LCD显示实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#485%E9%80%9A%E4%BF%A1%E5%AE%9E%E9%AA%8C"><span class="toc-number">30.</span> <span class="toc-text"> 485通信实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#i2c%E5%AE%9E%E9%AA%8C"><span class="toc-number">31.</span> <span class="toc-text"> I2C实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mpu6050%E5%AE%9E%E9%AA%8C"><span class="toc-number">32.</span> <span class="toc-text"> MPU6050实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spi%E5%AE%9E%E9%AA%8C"><span class="toc-number">33.</span> <span class="toc-text"> SPI实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24g%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E5%AE%9E%E9%AA%8C"><span class="toc-number">34.</span> <span class="toc-text"> 2.4G无线通信实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#oled%E6%98%BE%E7%A4%BA%E5%AE%9E%E9%AA%8C"><span class="toc-number">35.</span> <span class="toc-text"> OLED显示实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#can%E5%AE%9E%E9%AA%8C"><span class="toc-number">36.</span> <span class="toc-text"> CAN实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%8F%91%E7%94%9F%E5%99%A8"><span class="toc-number">37.</span> <span class="toc-text"> 硬件随机数发生器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E7%9C%8B%E9%97%A8%E7%8B%97%E5%AE%9E%E9%AA%8C"><span class="toc-number">38.</span> <span class="toc-text"> 窗口看门狗实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E7%9C%8B%E9%97%A8%E7%8B%97%E5%AE%9E%E9%AA%8C"><span class="toc-number">39.</span> <span class="toc-text"> 独立看门狗实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">40.</span> <span class="toc-text"> </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%85%E6%9C%BA%E5%94%A4%E9%86%92%E5%AE%9E%E9%AA%8C"><span class="toc-number">41.</span> <span class="toc-text"> 待机唤醒实验</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/12/31/%E4%B8%AA%E4%BA%BA%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6%E6%95%B0%E6%8D%AE%E6%89%8B%E5%86%8C%E5%90%88%E9%9B%86/" title="个人常用器件手册合集"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s3.ax1x.com/2021/03/01/6ieMFI.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="个人常用器件手册合集"/></a><div class="content"><a class="title" href="/2021/12/31/%E4%B8%AA%E4%BA%BA%E5%B8%B8%E7%94%A8%E5%99%A8%E4%BB%B6%E6%95%B0%E6%8D%AE%E6%89%8B%E5%86%8C%E5%90%88%E9%9B%86/" title="个人常用器件手册合集">个人常用器件手册合集</a><time datetime="2021-12-31T08:56:10.000Z" title="发表于 2021-12-31 16:56:10">2021-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/01/04/DIY%20STM32F103ZET6%E5%BC%80%E5%8F%91%E6%9D%BF/" title="DIY STM32F103ZET6开发板"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/letanga/MyPictureBed/img/src=http---hbimg.b0.upaiyun.com-89220c7fb5f05a43cc05dadf8b17891bf0d10b3c64b50-yi5NeT_fw658&amp;refer=http---hbimg.b0.upaiyun.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DIY STM32F103ZET6开发板"/></a><div class="content"><a class="title" href="/2021/01/04/DIY%20STM32F103ZET6%E5%BC%80%E5%8F%91%E6%9D%BF/" title="DIY STM32F103ZET6开发板">DIY STM32F103ZET6开发板</a><time datetime="2021-01-04T07:33:19.000Z" title="发表于 2021-01-04 15:33:19">2021-01-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/09/03/%E5%8D%8E%E7%A1%95UX433FN%E5%AE%89%E8%A3%85Win%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%8F%8C%E7%B3%BB%E7%BB%9F/" title="华硕UX433FN安装Win黑苹果双系统"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/letanga/MyPictureBed/img/20210601012451.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="华硕UX433FN安装Win黑苹果双系统"/></a><div class="content"><a class="title" href="/2020/09/03/%E5%8D%8E%E7%A1%95UX433FN%E5%AE%89%E8%A3%85Win%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%8F%8C%E7%B3%BB%E7%BB%9F/" title="华硕UX433FN安装Win黑苹果双系统">华硕UX433FN安装Win黑苹果双系统</a><time datetime="2020-09-03T06:09:17.000Z" title="发表于 2020-09-03 14:09:17">2020-09-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/05/12/Windows%20to%20go/" title="Windows to go"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2020/10/09/0DpUIK.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Windows to go"/></a><div class="content"><a class="title" href="/2020/05/12/Windows%20to%20go/" title="Windows to go">Windows to go</a><time datetime="2020-05-12T11:26:13.000Z" title="发表于 2020-05-12 19:26:13">2020-05-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/04/12/Excel%E7%94%9F%E6%88%90CSV%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6/" title="Excel生成CSV格式文件"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2020/10/26/BKSKvF.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Excel生成CSV格式文件"/></a><div class="content"><a class="title" href="/2020/04/12/Excel%E7%94%9F%E6%88%90CSV%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6/" title="Excel生成CSV格式文件">Excel生成CSV格式文件</a><time datetime="2020-04-12T10:36:13.000Z" title="发表于 2020-04-12 18:36:13">2020-04-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2016 - 2022 By Darren</div><div class="framework-info"><!-- span= _p('footer.framework') + ' '--><!-- a(href='https://hexo.io')= 'Hexo'--><!-- span.footer-separator |--><!-- span= _p('footer.theme') + ' '--><!-- a(href='https://github.com/jerryc127/hexo-theme-butterfly')= 'Butterfly'--></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://letanga.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'naJaIbSuo1stR1TBwyyAUJO0-gzGzoHsz',
      appKey: 'b8K2UcMoMjOg7RqUKXAuENHa',
      placeholder: '有什么想说的？',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener toc scroll 
  window.removeEventListener('scroll', window.tocScrollFn)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?letanga";
            var git_color =['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'];
            var git_user ="letanga";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><script data-pjax>function electric_clock_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img id="card-clock-loading" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-clock/clock/images/weather/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading" class="entered loading"></div></div></div></div></div>';
                console.log('已挂载electric_clock')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='all'|| 'all' ==='all')){

            electric_clock_injector_config()
        } </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax  src="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":250,"height":300},"mobile":{"show":true},"log":false});</script></body></html>